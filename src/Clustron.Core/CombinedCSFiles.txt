// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Bootstrap\ClustronBootstrapper.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Configuration;
using Clustron.Core.Extensions;
using Clustron.Core.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Console;

namespace Clustron.Core.Bootstrap;

public class ClustronBootstrapper
{
    private readonly IServiceCollection _services = new ServiceCollection();
    private IServiceProvider? _serviceProvider;
    private IConfiguration? _configuration;
    private IServiceCollection? _prebuiltServices;
    private IConfiguration? _externalConfig;

    
    public IServiceProvider Services => _serviceProvider
        ?? throw new InvalidOperationException("Bootstrapper not started yet");

    public IConfiguration Configuration => _configuration
        ?? throw new InvalidOperationException("Configuration not built");

    /// <summary>
    /// Allows external service registrations before starting.
    /// </summary>
    public void ConfigureServices(Action<IServiceCollection> configure)
    {
        configure(_services);
    }

    public void UseConfiguration(IConfiguration config)
    {
        _externalConfig = config;
    }

    public void Start(string[]? args = null)
    {
        // Build configuration from JSON, env, CLI
        //var configBuilder = new ConfigurationBuilder()
        //    .AddJsonFile("appsettings.json", optional: true)
        //    .AddEnvironmentVariables();

        //if (args != null)
        //    configBuilder.AddCommandLine(args);

        IConfiguration configuration;

        if (_externalConfig != null)
        {
            configuration = _externalConfig;
        }
        else
        {
            var builder = new ConfigurationBuilder()
                .AddJsonFile("appsettings.json", optional: true)
                .AddEnvironmentVariables();

            if (args != null)
                builder.AddCommandLine(args);

            configuration = builder.Build();
        }

        _configuration = configuration;

        _services.AddLogging(logging =>
        {
            logging.AddConfiguration(_configuration.GetSection("Logging")); 
            logging.AddConsole();                                           
        });

        // Build a logger factory from the service collection
        var tmpProvider = _services.BuildServiceProvider();
        var loggerFactory = tmpProvider.GetRequiredService<ILoggerFactory>();

        _services.AddSingleton(loggerFactory); 


        // Respect externally-injected ClustronConfig
        if (!_services.Any(s => s.ServiceType == typeof(ClustronConfig)))
        {
            var clustronConfig = _configuration.GetSection("Clustron").Get<ClustronConfig>()
                ?? throw new InvalidOperationException("Missing Clustron config");

            _services.AddSingleton(clustronConfig);
        }

        // Finalize DI
        _serviceProvider = _services.BuildServiceProvider();

        // Register core services using config + logger
        var config = _serviceProvider.GetRequiredService<ClustronConfig>();
        _services.Register(config, loggerFactory);

        // Build final provider with everything
        _serviceProvider = _services.BuildServiceProvider();

        var nodeHost = _serviceProvider.GetRequiredService<ClustronNodeHost>();
        nodeHost.StartAsync().GetAwaiter().GetResult();
    }

    public void UseServices(IServiceCollection services)    
    {
        _prebuiltServices = services;
    }

}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Client\ClustronClientCore.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io


using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Transport;
using Clustron.Core.Serialization;
using Clustron.Core.Cluster;
using Clustron.Core.Events;
using System.Collections.Concurrent;
using Clustron.Core.Configuration;
using Clustron.Abstractions;
using Clustron.Core.Observability;

namespace Clustron.Core.Client;

public class ClustronClientCore
{
    private readonly IMessageSerializer _serializer;
    private readonly NodeInfo _self;
    private readonly ClusterPeerManager _peerManager;
    private readonly IClusterEventBus _eventBus;
    private readonly IMetricContributor _metrics;
    private readonly ClusterNodeControllerBase _controller;

    private readonly ConcurrentDictionary<string, Func<byte[], string, Task>> _typedHandlers = new();

    public event Action<NodeInfo>? NodeJoined;
    public event Action<NodeInfo>? NodeLeft;
    public event Action<NodeInfo, int>? LeaderChanged;

    public ClustronClientCore(ClusterNodeControllerBase controller, IMetricContributor metrics, IMessageSerializer serializer)
    {
        _controller = controller;
        _serializer = serializer;
        _self = controller.Runtime.Self;
        _peerManager = controller.Runtime.PeerManager;
        _eventBus = controller.Runtime.EventBus;
        _metrics = metrics;
        
        _eventBus.Subscribe<NodeJoinedEvent>(e => NodeJoined?.Invoke(e.Node));
        _eventBus.Subscribe<NodeLeftEvent>(e => NodeLeft?.Invoke(e.Node));
        _eventBus.Subscribe<LeaderChangedEvent>(e => LeaderChanged?.Invoke(e.NewLeader, e.Epoch));
    }

    public IMessageSerializer Serializer => _serializer;
    public NodeInfo Self => _self;

    public async Task SendAsync(Message message, string targetNodeId)
    {
        await _controller.Communication.Transport.SendAsync(
            _peerManager.GetPeerById(targetNodeId), message);

        _metrics.Increment(MetricKeys.Msg.Direct.Sent);
    }

    public async Task BroadcastAsync(Message message, params string[] roles)
    {
        var recipients = _peerManager.GetActivePeers()
            .Where(p => roles.Length == 0 || p.Roles?.Intersect(roles, StringComparer.OrdinalIgnoreCase).Any() == true)
            .ToList();

        await _controller.Communication.Transport.BroadcastAsync(message, roles);

        _metrics.Increment(MetricKeys.Msg.Direct.Broadcasted);
    }

    public async Task PublishAsync<T>(T @event, EventDispatchOptions? options) where T : IClusterEvent
    {
        await _eventBus.PublishAsync(@event, options);

        _metrics.Increment(MetricKeys.Msg.Events.Published);
    }

    public void Subscribe<T>(Func<T, Task> handler) where T : IClusterEvent
    {
        _eventBus.Subscribe<T>(async evt =>
        {
            await handler(evt);

            // Track total delivered messages
            _metrics.Increment(MetricKeys.Msg.Events.Delivered);
        });
    }

    public void RegisterClientMessageHandler<T>(Func<T, string, Task> handler)
    {
        var messageType = MessageTypes.ClientMessage;

        _typedHandlers[messageType] = async (payloadBytes, senderId) =>
        {
            var deserialized = _serializer.Deserialize<T>(payloadBytes);
            await handler(deserialized, senderId);
            _metrics.Increment(MetricKeys.Msg.Direct.Received);
        };
    }


    public bool TryGetHandler(string messageType, out Func<byte[], string, Task> dispatcher)
    {
        return _typedHandlers.TryGetValue(messageType, out dispatcher);
    }

    public IEnumerable<NodeInfo> GetMembers() => _peerManager.GetPeersWithRole(ClustronRoles.Member);

    public IEnumerable<NodeInfo> GetMetricsCollectors() => _peerManager.GetPeersWithRole(ClustronRoles.MetricsCollector);
    public IEnumerable<NodeInfo> GetObservers() => _peerManager.GetPeersWithRole(ClustronRoles.Observer);

    public IEnumerable<NodeInfo> GetClients() => _peerManager.GetPeersWithRole(ClustronRoles.Client);

    public NodeInfo? GetCurrentLeader() => _controller.CurrentLeader;

    public IEnumerable<NodeInfo> GetPeersByRole(string role) =>
        _peerManager.GetActivePeers().Where(p => p.Roles?.Contains(role, StringComparer.OrdinalIgnoreCase) == true);

    public IEnumerable<NodeInfo> GetPeersExceptRole(string role) =>
        _peerManager.GetActivePeers().Where(p => p.Roles?.Contains(role, StringComparer.OrdinalIgnoreCase) == false);



    public bool IsPeerAlive(string nodeId) => _peerManager.IsAlive(nodeId);

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\ClusterContext.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Configuration;
using Clustron.Core.Discovery;
using Clustron.Core.Election;
using Clustron.Core.Events;
using Clustron.Core.Models;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Cluster
{
    public class ClusterContext : IClusterRuntime, IClusterCommunication, IClusterLoggerProvider,
                                    IElectionCoordinatorProvider, IClusterDiscovery
    {
        private ITransport _transport;
        private ElectionCoordinator _coordinator;
        private readonly ClustronConfig _clustronConfig;

        public NodeInfo Self { get; }
        public ITransport Transport => _transport;
        public IDiscoveryProvider DiscoveryProvider { get; }
        public ILoggerFactory LoggerFactory { get; }

        public ClusterPeerManager PeerManager { get; }
        public IClusterEventBus EventBus { get; }
        public ElectionCoordinator Coordinator => _coordinator;

        public ClustronConfig Configuration => _clustronConfig;

        public ClusterContext(
            NodeInfo self,
            ITransport transport,
            IDiscoveryProvider discoveryProvider,
            ClusterPeerManager peerManager,
            IClusterEventBus eventBus,
            ClustronConfig clustronConfig,
            ILoggerFactory loggerFactory)
        {
            Self = self;
            _transport = transport;
            DiscoveryProvider = discoveryProvider;
            PeerManager = peerManager;
            _clustronConfig = clustronConfig;
            EventBus = eventBus;
            LoggerFactory = loggerFactory;
        }

        public void OverrideTransport(ITransport realTransport)
        {
            _transport = realTransport;
        }

        public void SetElectionCoordinatory(ElectionCoordinator coordinator)
        {
            _coordinator = coordinator;
        }

        public ILogger<T> GetLogger<T>() => LoggerFactory.CreateLogger<T>();
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\ClusterNodeControllerBase.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using Clustron.Core.Cluster;
using Clustron.Core.Cluster.State;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;

public abstract class ClusterNodeControllerBase : IClusterNodeController, IClusterStateMutator
{
    protected readonly NodeInfo Self;
    protected readonly JoinManager JoinManager;
    protected readonly ILogger Logger;
    protected readonly ClusterPeerManager PeerManager;
    protected readonly IClusterCommunication ClusterCommunication;
    protected readonly IClusterRuntime ClusterRuntime;

    public virtual NodeInfo? CurrentLeader => PeerManager.GetLeader();
    public virtual int CurrentEpoch => PeerManager.GetCurrentEpoch();

    public IClusterCommunication Communication => ClusterCommunication;
    public IClusterRuntime Runtime => ClusterRuntime;

    protected ClusterNodeControllerBase(
        IClusterRuntime clusterRuntime,
        IClusterCommunication clusterCommunication,
        JoinManager joinManager,
        ILogger logger)
    {
        JoinManager = joinManager;
        PeerManager = clusterRuntime.PeerManager;
        Logger = logger;
        ClusterRuntime = clusterRuntime;

        Self = clusterRuntime.Self;
        ClusterCommunication = clusterCommunication;
    }

    public abstract Task StartAsync();

    public virtual async Task<bool> IsReachableAsync()
    {
        var leader = CurrentLeader;
        if (leader == null)
            return false;

        return await ClusterCommunication.Transport.CanReachNodeAsync(leader);
    }

    public bool IsSelfLeader() => CurrentLeader?.NodeId == Self.NodeId;

    public void SetLeader(NodeInfo leader, int epoch)
    {
        Logger.LogInformation("SetLeader called for {LeaderId} with epoch {Epoch}", leader?.NodeId ?? "<null>", epoch);
        bool success = PeerManager.TrySetLeader(leader, epoch);

        if (!success)
        {
            Logger.LogDebug("Leader not updated: rejected by ClusterPeerManager.");
        }
    }

    public void ForceLeader(NodeInfo leader, int epoch)
    {
        if (leader == null || string.IsNullOrWhiteSpace(leader.NodeId))
        {
            Logger.LogWarning("ForceLeader called with invalid leader.");
            return;
        }

        Logger.LogWarning("Forcing leader to {LeaderId} at epoch {Epoch}", leader.NodeId, epoch);
        PeerManager.TrySetLeader(leader, epoch);
    }

    public async Task HandleHeartbeatSuspectAsync(string suspectedNodeId, string reporterId)
    {
        Logger.LogWarning("Node {NodeId} suspected by {ReporterId}", suspectedNodeId, reporterId);
        if (!IsSelfLeader()) return;

        if (!PeerManager.IsAlive(suspectedNodeId)) return;

        var suspect = PeerManager.GetPeerById(suspectedNodeId);
        bool reachable = await Communication.Transport.CanReachNodeAsync(suspect);

        if (!reachable)
        {
            Logger.LogInformation("Confirmed unreachable: {NodeId}, removing...", suspectedNodeId);
            await PeerManager.TryRemovePeerAsync(suspect, _ => Task.FromResult(true));
        }
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\ClusterPeerManager.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using Clustron.Core.Events;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster
{
    public class ClusterPeerManager
    {
        private readonly PeerRegistry _registry;
        private readonly IClusterEventBus _eventBus;
        private readonly ILogger<ClusterPeerManager> _logger;

        private NodeInfo? _currentLeader;
        private int _currentEpoch;

        public NodeInfo Self => _registry.Self;

        public ClusterPeerManager(PeerRegistry registry, IClusterEventBus eventBus, ILogger<ClusterPeerManager> logger)
        {
            _registry = registry;
            _eventBus = eventBus;
            _logger = logger;
        }

        // --- PEER ADDITION ---
        public bool RegisterPeer(NodeInfo peer)
        {
            if (peer.NodeId == Self.NodeId)
                return false;

            bool isNew = _registry.RegisterPeer(peer);
            if (isNew)
            {
                _logger.LogInformation("Node joined: {NodeId}", peer.NodeId);
                _eventBus.Publish(new NodeJoinedEvent(peer));
            }

            return isNew;
        }

        // --- PEER REMOVAL (With Optional Vetting) ---
        public async Task<bool> TryRemovePeerAsync(NodeInfo peer, Func<NodeInfo, Task<bool>>? vettingCallback = null)
        {
            if (!_registry.IsAlive(peer.NodeId))
            {
                _logger.LogDebug("Peer {NodeId} not found in active peers", peer.NodeId);
                return true;
            }

            if (vettingCallback != null)
            {
                bool permitted = await vettingCallback(peer);
                if (!permitted)
                {
                    _logger.LogInformation("Removal vetoed for peer {NodeId}", peer.NodeId);
                    return false;
                }
            }

            bool wasAlive = _registry.MarkPeerDown(peer);
            if (wasAlive)
            {
                _logger.LogWarning("Node left: {NodeId}", peer.NodeId);
                _eventBus.Publish(new NodeLeftEvent(peer));
            }

            return true;
        }

        // --- LEADER MANAGEMENT ---
        public bool TrySetLeader(NodeInfo leader, int epoch)
        {
            if (leader == null || string.IsNullOrWhiteSpace(leader.NodeId))
            {
                _logger.LogWarning("TrySetLeader called with null or invalid leader.");
                return false;
            }

            if (_currentLeader?.NodeId == leader.NodeId)
            {
                if (epoch < _currentEpoch)
                {
                    _logger.LogWarning("Ignoring leader update for {LeaderId} with older epoch {Epoch}", leader.NodeId, epoch);
                    return false;
                }

                if (epoch == _currentEpoch)
                    return false;

                _logger.LogInformation("Updating epoch for leader {LeaderId}: {OldEpoch} ? {NewEpoch}", leader.NodeId, _currentEpoch, epoch);
                _currentEpoch = epoch;
                return true;
            }

            if (epoch < _currentEpoch)
            {
                _logger.LogWarning("Stale leader claim ignored from {LeaderId} (epoch {Epoch} < {CurrentEpoch})", leader.NodeId, epoch, _currentEpoch);
                return false;
            }

            string prev = _currentLeader?.NodeId ?? "<none>";
            _logger.LogCritical("Changing leader from {OldLeader} to {NewLeader} (epoch {Epoch})", prev, leader.NodeId, epoch);

            _currentLeader = leader;
            _currentEpoch = epoch;

            _eventBus.Publish(new LeaderChangedEvent(leader, epoch));
            return true;
        }

        public NodeInfo? GetLeader() => _currentLeader;
        public int GetCurrentEpoch() => _currentEpoch;

        // --- LIVENESS TRACKING ---
        public void MarkHeartbeatReceived(string nodeId) => _registry.MarkHeartbeatReceived(nodeId);
        public void RecordMissedHeartbeat(string nodeId) => _registry.RecordMissedHeartbeat(nodeId);
        public int GetMissCount(string nodeId) => _registry.GetMissCount(nodeId);
        public bool HasTimedOut(string nodeId, TimeSpan timeout) => _registry.HasTimedOut(nodeId, timeout);
        public bool IsAlive(string nodeId) => _registry.IsAlive(nodeId);

        // --- ACCESSORS ---
        public NodeInfo GetPeerById(string id) => _registry.GetPeer(id);
        public IEnumerable<NodeInfo> GetActivePeers() => _registry.GetActivePeers();
        public IEnumerable<NodeInfo> GetAllKnownPeers() => _registry.GetAllKnownPeers();
        public IEnumerable<NodeInfo> GetPeersWithRole(params string[] roles) => _registry.GetPeersWithRole(roles);
        public bool IsPeerKnown(string nodeId) => _registry.Contains(nodeId);

        public PeerRegistry Registry => _registry; // Consider making this internal-only
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\IClusterCommunication.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Transport;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster
{
    public interface IClusterCommunication
    {
        ITransport Transport { get; }
        void OverrideTransport(ITransport realTransport);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\IClusterDiscovery.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Discovery;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster
{
    public interface IClusterDiscovery
    {
        IDiscoveryProvider DiscoveryProvider { get; }
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\IClusterLoggerProvider.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster
{
    public interface IClusterLoggerProvider
    {
        ILogger<T> GetLogger<T>();
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\IClusterNodeController.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Lifecycle;
using Clustron.Core.Models;

public interface IClusterNodeController
{
    Task StartAsync();
    Task<bool> IsReachableAsync();
    bool IsSelfLeader();
}




// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\IClusterRuntime.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Configuration;
using Clustron.Core.Events;
using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster
{
    public interface IClusterRuntime
    {
        NodeInfo Self { get; }
        IClusterEventBus EventBus { get; }
        ClusterPeerManager PeerManager { get; }

        ClustronConfig Configuration { get; }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\JoinManager.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

    using Clustron.Core.Configuration;
    using Clustron.Core.Discovery;
    using Clustron.Core.Extensions;
    using Clustron.Core.Handshake;
    using Clustron.Core.Helpers;
    using Clustron.Core.Models;
    using Clustron.Core.Transport;
    using Microsoft.Extensions.Logging;
using System.Diagnostics;

namespace Clustron.Core.Cluster;

    public class JoinManager
    {
        private readonly ILogger<JoinManager> _logger;
        private readonly ClustronConfig _config;
        private readonly IHandshakeProtocol _handshakeProtocol;
        private readonly ClusterPeerManager _peerManager;
        private readonly IClusterDiscovery _clusterDiscovery;

        public JoinManager(IClusterRuntime clusterRuntime, IClusterDiscovery clusterDiscovery,
            IHandshakeProtocol handshakeProtocol, ClusterPeerManager peerManager,
            ClustronConfig config, IClusterLoggerProvider loggerProvider)
        { 
            _handshakeProtocol = handshakeProtocol;
            _peerManager = clusterRuntime.PeerManager;
            _config = config;
            _clusterDiscovery = clusterDiscovery;

            _logger = loggerProvider.GetLogger<JoinManager>();
        }

    public async Task<JoinResult> JoinClusterAsync(NodeInfo self)
    {
        _logger.LogInformation("Registering self to discovery...");
        await _clusterDiscovery.DiscoveryProvider.RegisterSelfAsync(self);

        _logger.LogInformation("Discovering peer nodes...");
        var discoveredPeers = (await _clusterDiscovery.DiscoveryProvider.DiscoverNodesAsync())
            .ExcludeSelf(self.NodeId)
            .ToList();

        _logger.LogInformation("Discovered peers: {Peers}", string.Join(", ", discoveredPeers.Select(p => $"{p.NodeId} ({p.Host}:{p.Port})")));
        _logger.LogInformation("Discovered {Count} peers: {Peers}",
            discoveredPeers.Count,
            string.Join(", ", discoveredPeers.Select(p => p.NodeId)));

        var acceptedPeers = new List<NodeInfo>();
        NodeInfo? knownLeader = null;
        int highestEpoch = 0;

        var handshakeTasks = discoveredPeers.Select(async peer =>
        {
            try
            {
                _logger.LogDebug("Attempting handshake with {Peer}", peer.NodeId);
                var result = await RetryHelper.RetryAsync(
                    () => _handshakeProtocol.InitiateHandshakeAsync(peer),
                    _config.RetryOptions.MaxAttempts,
                    _config.RetryOptions.DelayMilliseconds,
                    _logger);

                _logger.LogDebug("Handshake result from {Peer}: Accepted={Accepted}, Leader={Leader}",
                    peer.NodeId,
                    result.Accepted,
                    result.Leader?.NodeId ?? "none");

                return (Peer: peer, Result: result);
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Failed to handshake with {Peer}: {Error}", peer.NodeId, ex.Message);
                return (Peer: peer, Result: (null as HandshakeResponse));
            }
        }).ToList();

        var results = await Task.WhenAll(handshakeTasks);

        foreach (var (peer, result) in results)
        {
            if (result == null)
                continue;

            if (result.Accepted)
            {
                _logger.LogInformation("Handshake successful with {Peer}", peer.NodeId);

                _peerManager.RegisterPeer(result.ResponderNode);
                acceptedPeers.Add(result.ResponderNode);

                if (result.Leader != null && result.LeaderEpoch > highestEpoch)
                {
                    knownLeader = result.Leader;
                    highestEpoch = result.LeaderEpoch;
                }
            }
            else
            {
                _logger.LogWarning("Handshake rejected by {Peer}: {Reason}", peer.NodeId, result.Reason);
            }
        }

        _logger.LogInformation("Total accepted peers after join: {Count}", acceptedPeers.Count);
        return new JoinResult(acceptedPeers, knownLeader, highestEpoch);
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\JoinResult.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

    using Clustron.Core.Models;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    namespace Clustron.Core.Cluster
    {
    public class JoinResult
    {
        public List<NodeInfo> Peers { get; set; } = new();
        public NodeInfo? KnownLeader { get; set; }
        public int KnownLeaderEpoch { get; set; } = 0; 

        public JoinResult(List<NodeInfo> peers, NodeInfo? knownLeader, int epoch = 0)
        {
            Peers = peers;
            KnownLeader = knownLeader;
            KnownLeaderEpoch = epoch;
        }
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\PeerRegistry.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Discovery;
using Clustron.Core.Events;
using Clustron.Core.Extensions;
using Clustron.Core.Models;
using System.Collections.Concurrent;

namespace Clustron.Core.Cluster;

public class PeerRegistry
{
    private readonly NodeInfo _self;
    private readonly IDiscoveryProvider _discoveryProvider;
    private readonly ConcurrentDictionary<string, NodeInfo> _knownPeers = new();
    private readonly ConcurrentDictionary<string, NodeInfo> _activePeers = new();
    private readonly ConcurrentDictionary<string, DateTime> _lastSeen = new();
    private readonly ConcurrentDictionary<string, int> _missCounts = new();

    public NodeInfo Self => _self;
    public PeerRegistry(NodeInfo self, IDiscoveryProvider discoveryProvider)
    {
        _self = self;   
        _discoveryProvider = discoveryProvider;
    }

    public IEnumerable<NodeInfo> GetActivePeers()
    {
        return _activePeers.Values;
    }

    public IEnumerable<NodeInfo> GetAllKnownPeers()
    {
        return _knownPeers.Values;
    }

    public bool IsAlive(string nodeId)
    {
        return nodeId != _self.NodeId && _activePeers.ContainsKey(nodeId);
    }

    public bool RegisterPeer(NodeInfo peer)
    {
        if (peer.NodeId == _self.NodeId) return false;

        bool isNew = !_activePeers.ContainsKey(peer.NodeId);
        _knownPeers[peer.NodeId] = peer;
        _activePeers[peer.NodeId] = peer;
        _lastSeen[peer.NodeId] = DateTime.UtcNow;
        _missCounts[peer.NodeId] = 0;

        if(_discoveryProvider is IRuntimeUpdatableDiscovery updater)
            updater.RegisterPeerAsync(peer);

        return isNew;
    }

    public bool MarkPeerDown(NodeInfo peer)
    {
        if (!_activePeers.ContainsKey(peer.NodeId))
            return false;

        ClearLivenessTracking(peer.NodeId);
        return true;
    }

    public NodeInfo GetPeer(string id) =>
                _activePeers.Values.Where(p => p.NodeId == id).FirstOrDefault();

    public IEnumerable<NodeInfo> GetPeersWithRole(params string[] roles) =>
                roles.Length == 0
                    ? _activePeers.Values
                    : _activePeers.Values.Where(p => roles.Any(r => p.HasRole(r)));

    public IEnumerable<NodeInfo> GetPeersWithAnyRole(params string[] roles)
    {
        var roleSet = new HashSet<string>(roles, StringComparer.OrdinalIgnoreCase);
        return _activePeers.Values.Where(p =>
            p.Roles != null && p.Roles.Any(role => roleSet.Contains(role)));
    }

    public void MarkHeartbeatReceived(string nodeId)
    {
        _lastSeen[nodeId] = DateTime.UtcNow;
        _missCounts[nodeId] = 0;
    }

    public void RecordMissedHeartbeat(string nodeId)
    {
        _missCounts.AddOrUpdate(nodeId, 1, (_, val) => val + 1);
    }

    public bool HasTimedOut(string nodeId, TimeSpan timeout)
    {
        return _lastSeen.TryGetValue(nodeId, out var last) && (DateTime.UtcNow - last) > timeout;
    }

    public int GetMissCount(string nodeId) =>
        _missCounts.TryGetValue(nodeId, out var val) ? val : 0;

    public void ClearLivenessTracking(string nodeId)
    {
        _activePeers.TryRemove(nodeId, out _);
        _knownPeers.TryRemove(nodeId, out _);
        _lastSeen.TryRemove(nodeId, out _);
        _missCounts.TryRemove(nodeId, out _);
    }

    public bool Contains(string nodeId) => _knownPeers.ContainsKey(nodeId);
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\RoleAwareClusterController.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster.Behaviors;
using Clustron.Core.Events;
using Clustron.Core.Health;
using Clustron.Core.Lifecycle;
using Clustron.Core.Models;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster
{
    public class RoleAwareClusterController : ClusterNodeControllerBase
    {
        private readonly IEnumerable<IRoleAwareBehavior> _behaviors;
        private readonly IHeartbeatMonitor _heartbeatMonitor;
        private readonly ClusterPeerManager _peerManager;

        private readonly NodeInfo _self;

        public RoleAwareClusterController(
            IClusterRuntime clusterRuntime,
            JoinManager joinManager,
            IClusterCommunication communication,
            IHeartbeatMonitor heartbeatMonitor,
            IEnumerable<IRoleAwareBehavior> behaviors,
            IClusterLoggerProvider loggerProvider)
            : base(clusterRuntime, communication, joinManager, loggerProvider.GetLogger<RoleAwareClusterController>())
        {
            _behaviors = behaviors;
            _heartbeatMonitor = heartbeatMonitor;
            _self = clusterRuntime.Self;

            clusterRuntime.EventBus.Subscribe<NodeJoinedEvent>(e =>
            {
                PeerManager.RegisterPeer(e.Node);
            });

            clusterRuntime.EventBus.Subscribe<NodeLeftEvent>(e =>
            {
                Logger.LogWarning("Node left: {NodeId}", e.Node.NodeId);
            });

            clusterRuntime.EventBus.Subscribe<LeaderChangedEvent>(e =>
            {
                Logger.LogCritical("New leader: {NodeId} (Epoch {Epoch})", e.NewLeader.NodeId, e.Epoch);
            });
        }

        public override async Task StartAsync()
        {
            Logger.LogInformation("Joining cluster...");

            var result = await JoinManager.JoinClusterAsync(Self);

            foreach (var peer in result.Peers)
                PeerManager.RegisterPeer(peer);

            if (result.KnownLeader != null)
                SetLeader(result.KnownLeader, result.KnownLeaderEpoch);

            await Task.Delay(500); // allow handshakes to finish

            foreach (var behavior in _behaviors)
            {
                if (behavior is IRoleAwareBehavior roleAware && !roleAware.ShouldRunInRole(_self.Roles))
                {
                    Logger.LogInformation("Skipping behavior {Name} for roles: {Roles}", behavior.Name, string.Join(", ", _self.Roles));
                    continue;
                }

                Logger.LogInformation("Starting behavior: {RoleName}", behavior.Name);
                await behavior.StartAsync();
            }
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Configuration\ClustronConfig.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;

namespace Clustron.Core.Configuration;
public class ClustronConfig
{
    public string ClusterId { get; set; } = "default-cluster";
    public string Version { get; set; } = "1.0.0";
    public int Port { get; set; }
    public List<NodeInfo>? StaticNodes { get; set; }
    public int LogClusterViewIntervalSeconds { get; set; } = 0;
    public bool UseDuplexConnections { get; set; } = true;

    /// <summary>
    /// Optional list of roles this node is allowed to play (e.g., "leader", "metrics-only", etc.)
    /// </summary>
    public List<string> Roles { get; set; } = new();

    public MetricsOptions Metrics { get; set; } = new();
    public RetryOptions RetryOptions { get; set; } = new();
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Configuration\ClustronRoles.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Configuration
{
    public static class ClustronRoles
    {
        public const string Member = "member";                      // Full cluster participant
        public const string Observer = "observer";                  // Lifecycle + leader change only
        public const string MetricsCollector = "metrics-collector"; // Actively polls metrics
        public const string Client = "client";                      // Sends requests, no cluster awareness
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Configuration\MetricsOptions.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Configuration
{
    public class MetricsOptions
    {
        public int RollingWindowSeconds { get; set; } = 60;
        public int MetricsTimeoutMilliseconds { get; set; } = 5000;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Configuration\RetryOptions.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io


namespace Clustron.Core.Configuration;

public class RetryOptions
{
    public int MaxAttempts { get; set; } = 3;
    public int DelayMilliseconds { get; set; } = 500;
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Discovery\AdaptiveDiscoveryProvider.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Discovery
{
    public class AdaptiveDiscoveryProvider : IRuntimeUpdatableDiscovery
    {
        private readonly List<NodeInfo> _staticNodes;
        private readonly Dictionary<string, NodeInfo> _dynamicNodes = new();
        private readonly object _lock = new();

        public AdaptiveDiscoveryProvider(IEnumerable<NodeInfo> staticNodes)
        {
            _staticNodes = staticNodes.ToList();
        }

        public Task<IEnumerable<NodeInfo>> DiscoverNodesAsync()
        {
            lock (_lock)
            {
                var all = _staticNodes
                    .Concat(_dynamicNodes.Values)
                    .GroupBy(n => n.NodeId)
                    .Select(g => g.First())
                    .ToList();

                return Task.FromResult<IEnumerable<NodeInfo>>(all);
            }
        }

        public Task RegisterSelfAsync(NodeInfo self)
        {
            return RegisterPeerAsync(self); // treat self like a peer
        }

        public Task RegisterPeerAsync(NodeInfo peer)
        {
            lock (_lock)
            {
                _dynamicNodes[peer.NodeId] = peer;
            }

            return Task.CompletedTask;
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Discovery\IDiscoveryProvider.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;

namespace Clustron.Core.Discovery;

public interface IDiscoveryProvider
{
    Task<IEnumerable<NodeInfo>> DiscoverNodesAsync();
    Task RegisterSelfAsync(NodeInfo self);
}




// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Discovery\InMemoryDiscoveryProvider.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Discovery
{
    public class InMemoryDiscoveryProvider : IDiscoveryProvider
    {
        private readonly HashSet<string> _nodeIds = new();
        private readonly List<NodeInfo> _nodes = new();
        private readonly object _lock = new();

        public Task RegisterSelfAsync(NodeInfo self)
        {
            AddOrUpdate(self);
            return Task.CompletedTask;
        }

        public Task<IEnumerable<NodeInfo>> DiscoverNodesAsync()
        {
            lock (_lock)
            {
                // Return a copy to prevent mutation
                return Task.FromResult(_nodes.ToList().AsEnumerable());
            }
        }

        public void AddOrUpdate(NodeInfo node)
        {
            lock (_lock)
            {
                if (_nodeIds.Add(node.NodeId))
                {
                    _nodes.Add(node);
                }
            }
        }
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Discovery\IRuntimeUpdatableDiscovery.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Discovery
{
    public interface IRuntimeUpdatableDiscovery : IDiscoveryProvider
    {
        Task RegisterPeerAsync(NodeInfo peer);
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Discovery\StaticDiscoveryProvider.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Discovery;
using Clustron.Core.Models;

namespace Clustron.Core.Discovery;

public class StaticDiscoveryProvider : IDiscoveryProvider
{
    private readonly List<NodeInfo> _nodes;

    public StaticDiscoveryProvider(List<NodeInfo> nodes)
    {
        _nodes = nodes;
    }

    public Task<IEnumerable<NodeInfo>> DiscoverNodesAsync()
    {
        return Task.FromResult(_nodes.AsEnumerable());
    }

    public Task RegisterSelfAsync(NodeInfo self)
    {
        return Task.CompletedTask;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Election\BullyElectionStrategy.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Configuration;
using Clustron.Core.Extensions;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Election
{
    public class BullyElectionStrategy : IElectionStrategy
    {
        private readonly TimeSpan _electionTimeout;
        private readonly ILogger<BullyElectionStrategy> _logger;
        private readonly IClusterRuntime _clusterRuntime;

        public BullyElectionStrategy(
            IClusterRuntime clusterRuntime,
            IClusterLoggerProvider loggerProvider,
            TimeSpan? electionTimeout = null)
        {
            _clusterRuntime= clusterRuntime;
            _logger = loggerProvider.GetLogger<BullyElectionStrategy>();
            _electionTimeout = electionTimeout ?? TimeSpan.FromSeconds(3);
        }

        public async Task<NodeInfo?> ElectLeaderAsync(IEnumerable<NodeInfo> knownNodes, NodeInfo self)
        {
            var allNodes = knownNodes.Append(self).ToList();

            _logger.LogDebug($"[Election] {self.NodeId} sees total nodes: {allNodes.Count}");
            foreach (var node in allNodes)
                _logger.LogDebug($"[Election] Node in cluster: {node.NodeId}");

            var higherNodes = allNodes
                .Where(n => string.Compare(n.NodeId, self.NodeId, StringComparison.Ordinal) > 0
                        && n.HasRole(ClustronRoles.Member))
                .ToList();

            _logger.LogDebug($"[Election] {self.NodeId} sees {higherNodes.Count} higher-priority nodes.");
            foreach (var node in higherNodes)
                _logger.LogDebug($"[Election] Higher node: {node.NodeId}");

            if (!higherNodes.Any())
            {
                _logger.LogInformation($"[Election] {self.NodeId} becomes leader (no higher nodes).");
                return self;
            }

            _logger.LogDebug($"[Election] {self.NodeId} checking if higher nodes are alive...");

            var tasks = higherNodes.Select(async node =>
            {
                try
                {
                    using var cts = new CancellationTokenSource(_electionTimeout);
                    var response = _clusterRuntime.PeerManager.IsAlive(node.NodeId);

                    _logger.LogDebug($"[Election] Response from {node.NodeId}: {(response ? "OK" : "No response")}");
                    return response;
                }
                catch (Exception ex)
                {
                    _logger.LogError($"[Election] Exception contacting {node.NodeId}: {ex.Message}");
                    return false;
                }
            }).ToList();

            var responses = await Task.WhenAll(tasks);
            var responsiveHigherExists = responses.Any(r => r);

            if (!responsiveHigherExists)
            {
                _logger.LogInformation($"[Election] {self.NodeId} becomes leader (no higher nodes responded).");
                return self;
            }

            _logger.LogInformation($"[Election] {self.NodeId} will not become leader; higher nodes responded.");
            return null;
        }
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Election\ElectionCoordinator.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Election;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Election;

public class ElectionCoordinator
{
    private readonly NodeInfo _self;
    private readonly IElectionStrategy _electionStrategy;
    private readonly ILogger<ElectionCoordinator> _logger;

    private bool _electionInProgress = false;
    private DateTime _lastElectionTime = DateTime.MinValue;
    private readonly TimeSpan _electionCooldown = TimeSpan.FromSeconds(3);

    public ElectionCoordinator(
        NodeInfo self,
        IElectionStrategy electionStrategy,
        ILogger<ElectionCoordinator> logger)
    {
        _self = self;
        _electionStrategy = electionStrategy;
        _logger = logger;
    }

    public async Task<NodeInfo?> ElectLeaderAsync(IEnumerable<NodeInfo> activePeers)
    {
        if (_electionInProgress || DateTime.UtcNow - _lastElectionTime < _electionCooldown)
        {
            _logger.LogWarning("Election skipped: already in progress or cooldown.");
            return null;
        }

        _electionInProgress = true;
        _lastElectionTime = DateTime.UtcNow;

        try
        {
            _logger.LogInformation("Running election among: {Peers}", string.Join(", ", activePeers.Select(p => p.NodeId)));
            var elected = await _electionStrategy.ElectLeaderAsync(activePeers, _self);

            if (elected == null)
            {
                _logger.LogWarning("No eligible leader could be elected.");
            }

            return elected;
        }
        finally
        {
            _electionInProgress = false;
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Election\IElectionCoordinatorProvider.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Election
{
    public interface IElectionCoordinatorProvider
    {
        ElectionCoordinator Coordinator { get; }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Election\IElectionStrategy.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;

namespace Clustron.Core.Election
{
    public interface IElectionStrategy
    {
        Task<NodeInfo?> ElectLeaderAsync(IEnumerable<NodeInfo> knownNodes, NodeInfo self);
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Election\ILeaderElectionCallback.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Election
{
    public interface ILeaderElectionCallback
    {
        Task OnNewLeaderElected(NodeInfo leader, int epoch);
        Task OnLeaderFailure(string failedLeaderId);
        NodeInfo? CurrentLeader { get; }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Election\ILeaderElectionService.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Election
{
    public interface ILeaderElectionService
    {
        Task TryHoldElectionAsync();
        NodeInfo? CurrentLeader { get; }
        int CurrentEpoch { get; }
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Election\LeaderElectionService.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Cluster.State;
using Clustron.Core.Events;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Election
{
    public class LeaderElectionService : ILeaderElectionService
    {
        private readonly ElectionCoordinator _coordinator;
        private readonly ClusterPeerManager _peerManager;
        private readonly IClusterStateMutator _state;
        private readonly NodeInfo _self;
        private readonly ILogger<LeaderElectionService> _logger;
        private readonly IClusterCommunication _communicationProvider;

        private bool _electionInProgress = false;
        private DateTime _lastElectionTime = DateTime.MinValue;
        private readonly TimeSpan _cooldown = TimeSpan.FromSeconds(3);

        public LeaderElectionService(
            IElectionCoordinatorProvider coordinatorProvider,
            IClusterRuntime clusterRuntime,
            IClusterStateMutator state,
            IClusterCommunication communicationProvider,
            IClusterLoggerProvider loggerProvider)
        {
            _coordinator = coordinatorProvider.Coordinator;
            _state = state;
            _self = clusterRuntime.Self;
            _peerManager = clusterRuntime.PeerManager;
            _communicationProvider = communicationProvider;
            _logger = loggerProvider.GetLogger<LeaderElectionService>();
        }

        public NodeInfo? CurrentLeader => _state.CurrentLeader;
        public int CurrentEpoch => _state.CurrentEpoch;

        public async Task TryHoldElectionAsync()
        {

            if (_electionInProgress)
            {
                _logger.LogInformation("Election already in progress.");
                return;
            }

            var now = DateTime.UtcNow;
            var timeSinceLast = now - _lastElectionTime;

            if (timeSinceLast < _cooldown)
            {
                var delay = _cooldown - timeSinceLast;
                _logger.LogInformation("Election cooldown active. Delaying by {Delay}ms", delay.TotalMilliseconds);
                await Task.Delay(delay);
            }

            _electionInProgress = true;
            _lastElectionTime = DateTime.UtcNow;

            try
            {
                var leader = await _coordinator.ElectLeaderAsync(_peerManager.GetActivePeers());
                if (leader != null)
                {
                    int newEpoch = CurrentEpoch + 1;
                    _state.SetLeader(leader, newEpoch);

                    var payload = new LeaderChangedEvent(leader, newEpoch);
                    var correlationId = Guid.NewGuid().ToString();
                    var message = MessageBuilder.Create<LeaderChangedEvent>(_self.NodeId, MessageTypes.LeaderChanged, correlationId, payload);
                    await _communicationProvider.Transport.BroadcastAsync(message);
                }
            }
            finally
            {
                _electionInProgress = false;
            }
        }
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\AsyncClusterEventBus.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System.Collections.Concurrent;
using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Configuration;
using Clustron.Core.Helpers;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Events;

public class AsyncClusterEventBus : IClusterEventBus
{
    private readonly ILogger<AsyncClusterEventBus> _logger;
    private readonly IMessageSerializer _serializer;
    private readonly Func<Func<IClusterEvent, Task>, IEventQueue<IClusterEvent>> _queueFactory;

    private IClusterCommunication _communication = null!;
    private NodeInfo _self = null!;

    private readonly ConcurrentDictionary<Type, List<Func<IClusterEvent, Task>>> _handlers = new();
    private readonly ConcurrentDictionary<string, Func<byte[], IClusterEvent>> _deserializers = new();
    private readonly ConcurrentDictionary<Func<IClusterEvent, Task>, IEventQueue<IClusterEvent>> _handlerQueues = new();

    public AsyncClusterEventBus(
        ILogger<AsyncClusterEventBus> logger,
        IMessageSerializer serializer,
        Func<Func<IClusterEvent, Task>, IEventQueue<IClusterEvent>>? queueFactory = null)
    {
        _logger = logger;
        _serializer = serializer;
        _queueFactory = queueFactory ?? (handler => new ChannelEventQueue<IClusterEvent>(handler, logger));
    }

    public void Configure(IClusterCommunication communication, NodeInfo self)
    {
        _communication = communication;
        _self = self;
    }

    public void Subscribe<T>(Func<T, Task> asyncHandler) where T : IClusterEvent
    {
        Func<IClusterEvent, Task> wrapper = e => asyncHandler((T)e);

        _handlers.AddOrUpdate(
            typeof(T),
            _ => new List<Func<IClusterEvent, Task>> { wrapper },
            (_, existing) => { lock (existing) existing.Add(wrapper); return existing; });

        _deserializers.TryAdd(typeof(T).AssemblyQualifiedName!, payload =>
            _serializer.Deserialize<T>(payload)!);

        var queue = _queueFactory(wrapper);
        queue.Start();

        _handlerQueues.TryAdd(wrapper, queue);
    }

    public void Subscribe<T>(Action<T> handler) where T : IClusterEvent
    {
        Subscribe<T>(e =>
        {
            handler(e);
            return Task.CompletedTask;
        });
    }

    public async Task PublishAsync(IClusterEvent evt, EventDispatchOptions? options = null)
    {
        options ??= new EventDispatchOptions();
        var type = evt.GetType();

        if (options.Scope == DeliveryScope.ClusterWide)
            await BroadcastEventAsync(evt, type);

        if (!_handlers.TryGetValue(type, out var handlerList))
            return;

        switch (options.Policy)
        {
            case DispatchPolicy.FireAndForget:
                foreach (var handler in handlerList.ToArray())
                    _ = Task.Run(() => handler(evt));
                break;

            case DispatchPolicy.Ordered:
                foreach (var handler in handlerList.ToArray())
                {
                    if (_handlerQueues.TryGetValue(handler, out var queue))
                        queue.Enqueue(evt);
                }
                break;

            case DispatchPolicy.Parallel:
                await Task.WhenAll(handlerList.ToArray().Select(h => h(evt)));
                break;

            case DispatchPolicy.Retry:
                foreach (var handler in handlerList.ToArray())
                {
                    await RetryHelper.RetryAsync(
                        () => handler(evt),
                        options.MaxRetryAttempts,
                        options.RetryDelayMilliseconds,
                        _logger);
                }
                break;
        }
    }

    public void Publish(IClusterEvent evt)
        => PublishAsync(evt).GetAwaiter().GetResult();

    public async Task PublishFromNetworkAsync(byte[] payload, string eventType)
    {
        if (_deserializers.TryGetValue(eventType, out var factory))
        {
            var evt = factory(payload);
            await PublishAsync(evt, new EventDispatchOptions { Scope = DeliveryScope.LocalOnly });
        }
    }

    private async Task BroadcastEventAsync(IClusterEvent evt, Type type)
    {
        var message = MessageBuilder.Create(
            _self.NodeId,
            evt.EventType,
            type.AssemblyQualifiedName!,
            evt);

        var targetRoles = evt.EventType == MessageTypes.CustomEvent
            ? new[] { ClustronRoles.Member }
            : Array.Empty<string>();

        await _communication.Transport.BroadcastAsync(message, targetRoles);
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\ClusterAwareEventPublisher.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using Clustron.Abstractions;
using Clustron.Core.Messaging;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public class ClusterAwareEventPublisher
    {
        private readonly IClusterEventBus _eventBus;
        private readonly ITransport _transport;
        private readonly IMessageSerializer _serializer;
        private readonly string _nodeId;

        public ClusterAwareEventPublisher(
            IClusterEventBus eventBus,
            ITransport transport,
            IMessageSerializer serializer,
            string nodeId)
        {
            _eventBus = eventBus;
            _transport = transport;
            _serializer = serializer;
            _nodeId = nodeId;
        }

        //public async Task PublishAsync(IClusterEvent evt)
        //{
        //    // Local dispatch
        //    await _eventBus.PublishAsync(evt);

        //    // If this is a cluster-wide event, broadcast it
        //    if (evt is { Scope: ClusterEventScope.ClusterWide })
        //    {
        //        var message = new Message
        //        {
        //            MessageType = MessageTypes.CustomEvent,
        //            SenderId = _nodeId,
        //            CorrelationId = Guid.NewGuid().ToString(),
        //            Payload = SerializeWithKnownType(evt)
        //        };

        //        await _transport.BroadcastAsync(message);
        //    }
        //}

        //private byte[] SerializeWithKnownType(IClusterEvent evt)
        //{
        //    var type = evt.GetType();
        //    var method = typeof(IMessageSerializer).GetMethod("Serialize")!
        //        .MakeGenericMethod(type);

        //    return (byte[])method.Invoke(_serializer, new object[] { evt })!;
        //}
    }

}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\ClusterEventBase.cs
    // Copyright (c) 2025 zeroheartbeat
    //
    // Use of this software is governed by the Business Source License 1.1,
    // included in the LICENSE file in the root of this repository.
    //
    // Production use is not permitted without a commercial license from the Licensor.
    // To obtain a license for production, please contact: support@clustron.io

    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;

    namespace Clustron.Core.Events
    {
        public abstract class ClusterEventBase<T> : IClusterEvent
        {
            public T Payload { get; init; } = default!;
            public DateTime Timestamp { get; init; } = DateTime.UtcNow;

            public ClusterEventScope Scope => ClusterEventScope.ClusterWide;

            public string EventType { get; init; }
        }
    }



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\ClusterEventScope.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public enum ClusterEventScope
    {
        LocalOnly,
        ClusterWide
    }

}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\DeliveryScope.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public enum DeliveryScope
    {
        LocalOnly,
        ClusterWide
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\DispatchPolicy.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public enum DispatchPolicy
    {
        FireAndForget,
        Ordered,
        Parallel,
        Retry
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\EventDispatchOptions.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public class EventDispatchOptions
    {
        public DispatchPolicy Policy { get; set; } = DispatchPolicy.Ordered;
        public int MaxRetryAttempts { get; set; } = 3;
        public int RetryDelayMilliseconds { get; set; } = 200;

        public DeliveryScope Scope { get; set; } = DeliveryScope.ClusterWide; // default
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\HeartbeatSuspect.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public class HeartbeatSuspect
    {
        public NodeInfo SuspectedNode { get; init; }
        public HeartbeatSuspect(NodeInfo suspectedNode) 
        {
            SuspectedNode = suspectedNode;
        }
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\IClusterEvent.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public interface IClusterEvent
    {
        ClusterEventScope Scope { get; }

        string EventType { get; }
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\IClusterEventBus.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public interface IClusterEventBus
    {
        void Publish(IClusterEvent evt);

        Task PublishAsync(IClusterEvent evt, EventDispatchOptions? options = null);
        void Subscribe<T>(Action<T> handler) where T : IClusterEvent;
        void Subscribe<T>(Func<T, Task> asyncHandler) where T : IClusterEvent;

        Task PublishFromNetworkAsync(byte[] payload, string eventType);

        void Configure(IClusterCommunication communication, NodeInfo self);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\LeaderChangedEvent.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Messaging;
using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public class LeaderChangedEvent : ClusterEventBase<(NodeInfo Leader, int Epoch)>
    {
        public NodeInfo NewLeader { get; }
        public int Epoch { get; }

        public LeaderChangedEvent(NodeInfo newLeader, int epoch)
        {
            NewLeader = newLeader;
            Epoch = epoch;
            EventType = MessageTypes.LeaderChanged;
        }
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\NodeJoinedEvent.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Messaging;
using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public sealed class NodeJoinedEvent : ClusterEventBase<NodeInfo>
    {
        public NodeJoinedEvent(NodeInfo node) {
            EventType = MessageTypes.NodeJoined;
            Node = node;
        }
        public NodeInfo Node { get; }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Events\NodeLeftEvent.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Messaging;
using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Events
{
    public sealed class NodeLeftEvent : ClusterEventBase<NodeInfo>
    {
        public NodeLeftEvent(NodeInfo node) 
        {
            EventType = MessageTypes.NodeLeft;
            Node = node;
        }
        public NodeInfo Node { get; }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Extensions\NodeInfoExtensions.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Extensions
{
    public static class NodeInfoExtensions
    {
        public static IEnumerable<NodeInfo> ExcludeSelf(this IEnumerable<NodeInfo> nodes, string selfId)
        {
            return nodes.Where(n => n.NodeId != selfId);
        }

        public static IEnumerable<NodeInfo> ExcludeNodes(this IEnumerable<NodeInfo> nodes, params string[] excludedIds)
        {
            var excluded = excludedIds.ToHashSet();
            return nodes.Where(n => !excluded.Contains(n.NodeId));
        }

    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Extensions\RoleExtensions.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Configuration;
using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Extensions
{
    public static class RoleExtensions
    {
        public static bool HasRole(this NodeInfo node, string role) =>
            node.Roles?.Any(r => r.Equals(role, StringComparison.OrdinalIgnoreCase)) == true;
        public static bool IsMember(this NodeInfo node) => node.HasRole(ClustronRoles.Member);
        public static bool IsObserver(this NodeInfo node) => node.HasRole(ClustronRoles.Observer);
        public static bool IsMetricsCollector(this NodeInfo node) => node.HasRole(ClustronRoles.MetricsCollector);
        public static bool IsClient(this NodeInfo node) => node.HasRole(ClustronRoles.Client);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Extensions\StreamExtensions.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Extensions
{
    public static class StreamExtensions
    {
        public static async Task ReadExactlyAsync(this Stream stream, byte[] buffer, int offset, int count)
        {
            int readTotal = 0;
            while (readTotal < count)
            {
                int read = await stream.ReadAsync(buffer, offset + readTotal, count - readTotal);
                if (read == 0)
                    throw new IOException("Stream closed before reading enough bytes.");
                readTotal += read;
            }
        }
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\ClusterEventMessageHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using Clustron.Abstractions;
using Clustron.Core.Events;
using Clustron.Core.Messaging;
using Clustron.Core.Serialization;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Handlers
{
    public class ClusterEventMessageHandler : IMessageHandler
    {
        private readonly IClusterEventBus _eventBus;
        private readonly IMessageSerializer _serializer;
        private readonly string _localNodeId;

        public string Type => MessageTypes.CustomEvent;

        public ClusterEventMessageHandler(
            IClusterEventBus eventBus,
            IMessageSerializer serializer,
            string localNodeId)
        {
            _eventBus = eventBus;
            _localNodeId = localNodeId;
            _serializer = serializer;
        }

        public Task HandleAsync(Message message)
        {
            if (message.SenderId == _localNodeId)
                return Task.CompletedTask;

            return _eventBus.PublishFromNetworkAsync(message.Payload, message.CorrelationId);
        }
    }

}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\ClusterViewHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Extensions;
using Clustron.Core.Handshake;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Handlers;

public class ClusterViewHandler : IMessageHandler
{
    private readonly ILogger<ClusterViewHandler> _logger;
    private readonly IMessageSerializer _serializer;
    private readonly IClusterRuntime _runtime;
    private readonly IHandshakeProtocol _handshake;

    public string Type => MessageTypes.ClusterView;

    public ClusterViewHandler(
        ILogger<ClusterViewHandler> logger,
        IMessageSerializer serializer,
        IClusterRuntime runtime,
        IHandshakeProtocol handshake)
    {
        _logger = logger;
        _serializer = serializer;
        _runtime = runtime;
        _handshake = handshake;
    }

    public async Task HandleAsync(Message message)
    {
        var payload = _serializer.Deserialize<ClusterViewPayload>(message.Payload);
        if (payload == null || payload.KnownPeers == null)
            return;

        _logger.LogCritical("KnownPeers received from {Sender} : {Peers}", message.SenderId, string.Join(", ", payload.KnownPeers.Select(p => $"{p.NodeId} (Roles: {string.Join("|", p.Roles)})")));

        foreach (var peer in payload.KnownPeers)
        {
            if (peer.NodeId == _runtime.Self.NodeId)
                continue;

            if (!peer.IsMember())
                continue;

            if (!_runtime.PeerManager.IsPeerKnown(peer.NodeId))
            {
                _logger.LogInformation("Discovered unknown peer {NodeId} via cluster view. Attempting handshake...", peer.NodeId);
                try
                {
                    await _handshake.InitiateHandshakeAsync(peer);
                    _logger.LogInformation("Successfully connected to {NodeId} via cluster view.", peer.NodeId);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning("Handshake with {NodeId} failed: {Error}", peer.NodeId, ex.Message);
                }
            }
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\HandshakeRequestHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Handshake;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Handlers;

public class HandshakeRequestHandler : IMessageHandler
{
    private readonly IHandshakeProtocol _protocol;
    private readonly IMessageSerializer _serializer;
    private readonly NodeInfo _self;
    private readonly ILogger<HandshakeRequestHandler> _logger;
    private readonly IClusterCommunication _communication;

    public HandshakeRequestHandler(
        IClusterRuntime clusterRuntime,
        IClusterCommunication communication,
        IHandshakeProtocol protocol,
        IMessageSerializer serializer, IClusterLoggerProvider loggerProvider)
    {
        _protocol = protocol;
        _serializer = serializer;
        _self = clusterRuntime.Self;
        _communication = communication; 
        _logger = loggerProvider.GetLogger< HandshakeRequestHandler>();
    }

    public string Type => MessageTypes.HandshakeRequest;

    public async Task HandleAsync(Message message)
    {
        var request = _serializer.Deserialize<HandshakeRequest>(message.Payload);
        if (request == null)
        {
            _logger.LogWarning("Received invalid handshake payload.");
            return;
        }

        var result = await _protocol.ProcessHandshake(request);

        var response = new HandshakeResponse
        {
            Accepted = result.Accepted,
            Reason = result.Reason,
            Leader = result.Leader,
            LeaderEpoch = result.LeaderEpoch,
            ResponderNode = _self 
        };

        var responseMessage = MessageBuilder.Create<HandshakeResponse>(_self.NodeId, MessageTypes.HandshakeResponse, message.CorrelationId, response);

        await _communication.Transport.SendAsync(request.Sender, responseMessage);

        _logger.LogInformation("Sent handshake response to {PeerId}, CorrelationId={CorrelationId}",
            request.Sender?.NodeId ?? "<unknown>", message.CorrelationId);
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\HandshakeResponseHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Cluster.State;
using Clustron.Core.Handshake;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;
using System.Text;
using System.Text.Json;

namespace Clustron.Core.Handlers
{
    public class HandshakeResponseHandler : IMessageHandler
    {
        private readonly IClusterState _clusterLeader;
        private readonly ILogger<HandshakeResponseHandler> _logger;
        private readonly IMessageSerializer _serializer;
        private readonly IClusterRuntime _runtime;

        public HandshakeResponseHandler(IClusterState clusterLeader, IClusterRuntime runtime, IMessageSerializer serializer, ILogger<HandshakeResponseHandler> logger)
        {
            _clusterLeader = clusterLeader;
            _serializer = serializer;  
            _runtime = runtime;
            _logger = logger;
        }

        public string Type => MessageTypes.HandshakeResponse;

        public Task HandleAsync(Message message)
        {
            var response = _serializer.Deserialize<HandshakeResponse>(message.Payload);

            if (response?.Accepted == true)
            {
                _runtime.PeerManager.RegisterPeer(response.ResponderNode);
            }

            if (response?.Leader != null)
            {
                _clusterLeader.ForceLeader(response.Leader, response.LeaderEpoch);
                _logger.LogInformation("Adopting cluster leader from handshake: {LeaderId} (epoch {Epoch})",
                    response.Leader.NodeId, response.LeaderEpoch);
            }

            return Task.CompletedTask;
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\HeartbeatHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Health;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;
using System.Net.WebSockets;

namespace Clustron.Core.Handlers;
public class HeartbeatHandler : IMessageHandler
{
    private readonly IHeartbeatMonitor _monitor;
    private readonly ILogger<HeartbeatHandler> _logger;
    private readonly IMessageSerializer _serializer;


    public string Type => MessageTypes.Heartbeat;

    public HeartbeatHandler(IHeartbeatMonitor monitor, IClusterLoggerProvider loggerProvider, IMessageSerializer serializer)
    {
        _monitor = monitor;
        _logger = loggerProvider.GetLogger<HeartbeatHandler>();
        _serializer = serializer;

    }

    public Task HandleAsync(Message message)
    {
        _logger.LogDebug("Received heartbeat from {SenderId}", message.SenderId);
        _monitor.MarkHeartbeatReceived(message.SenderId);
        return Task.CompletedTask;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\HeartbeatSuspectHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Events;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Handlers
{
    public class HeartbeatSuspectHandler : IMessageHandler
    {
        private readonly ClusterNodeControllerBase _clusterLeader;
        private readonly NodeInfo _localNode;
        private readonly ILogger<HeartbeatSuspectHandler> _logger;
        private readonly IMessageSerializer _serializer;

        public HeartbeatSuspectHandler(
            ClusterNodeControllerBase clusterLeader,
            NodeInfo localNode, IMessageSerializer serializer,
            ILogger<HeartbeatSuspectHandler> logger)
        {
            _clusterLeader = clusterLeader;
            _localNode = localNode;
            _serializer = serializer;
            _logger = logger;
        }

        public string Type => MessageTypes.HeartbeatSuspect;

        public async Task HandleAsync(Message message)
        {
            var suspect = _serializer.Deserialize<HeartbeatSuspect>(message.Payload);
            _logger.LogWarning("Received HeartbeatSuspect for node: {NodeId} from {Sender}", suspect.SuspectedNode.NodeId, message.SenderId);

            if (_clusterLeader.CurrentLeader?.NodeId == _localNode.NodeId)
            {
                await _clusterLeader.HandleHeartbeatSuspectAsync(suspect.SuspectedNode.NodeId, message.SenderId);
            }
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\LeaderChangedHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Events;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;
using System.Text;
using System.Text.Json;

namespace Clustron.Core.Handlers
{
    public class LeaderChangedHandler : IMessageHandler
    {
        private readonly ClusterNodeControllerBase _clusterLeader;
        private readonly ILogger<LeaderChangedHandler> _logger;
        private readonly IMessageSerializer _serializer;

        public LeaderChangedHandler(ClusterNodeControllerBase clusterLeader, IMessageSerializer serializer, ILogger<LeaderChangedHandler> logger)
        {
            _clusterLeader = clusterLeader;
            _serializer = serializer;
            _logger = logger;
        }

        public string Type => MessageTypes.LeaderChanged;

        public async Task HandleAsync(Message message)
        {
            var payload = _serializer.Deserialize<LeaderChangedEvent>(message.Payload);

            if (payload?.NewLeader == null || string.IsNullOrWhiteSpace(payload.NewLeader.NodeId))
            {
                _logger.LogCritical($"Received LeaderChanged with null leader from {message.SenderId}  ignoring.");
                return;
            }

            var incomingLeader = payload.NewLeader;
            var incomingEpoch = payload.Epoch;
            var currentLeader = _clusterLeader.CurrentLeader;
            var currentEpoch = _clusterLeader.CurrentEpoch;

            if (incomingEpoch < currentEpoch)
            {
                _logger.LogWarning("Ignoring stale LeaderChanged: IncomingEpoch={IncomingEpoch} < CurrentEpoch={CurrentEpoch}",
                    incomingEpoch, currentEpoch);
                return;
            }

            if (incomingEpoch == currentEpoch)
            {
                if (currentLeader?.NodeId == incomingLeader.NodeId)
                {
                    _logger.LogDebug("Leader match and same epoch  ignoring.");
                    return;
                }

                // Tie-breaker
                var isCurrentReachable = await _clusterLeader.IsReachableAsync();

                if (!isCurrentReachable)
                {
                    _logger.LogWarning("Current leader unreachable  switching to incoming leader: {IncomingId}", incomingLeader.NodeId);
                    _clusterLeader.ForceLeader(incomingLeader, incomingEpoch);
                }
                else
                {
                    int cmp = string.CompareOrdinal(incomingLeader.NodeId, currentLeader.NodeId);
                    if (cmp < 0)
                    {
                        _logger.LogWarning("Incoming leader wins lexical tie-breaker  accepting: {IncomingId}", incomingLeader.NodeId);
                        _clusterLeader.ForceLeader(incomingLeader, incomingEpoch);
                    }
                    else
                    {
                        _logger.LogInformation("Current leader retained over {IncomingId} (tie-breaker).", incomingLeader.NodeId);
                    }
                }

                return;
            }

            // Incoming epoch is higher
            _logger.LogInformation("Newer leader received: {IncomingId} with epoch {Epoch}", incomingLeader.NodeId, incomingEpoch);
            _clusterLeader.ForceLeader(incomingLeader, incomingEpoch);
        }


    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\MetricsRequestHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Observability;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Handlers
{
    public class MetricsRequestHandler : IMessageHandler
    {
        private readonly ILogger<MetricsRequestHandler> _logger;
        private readonly IMetricsSnapshotProvider _snapshotProvider;
        private readonly IMessageSerializer _serializer;
        private readonly IClusterRuntime _runtime;
        private readonly IClusterCommunication _communication;

        public string Type => MessageTypes.RequestMetrics;

        public MetricsRequestHandler(
            ILogger<MetricsRequestHandler> logger,
            IMetricsSnapshotProvider snapshotProvider,
            IMessageSerializer serializer,
            IClusterRuntime clusterRuntime,
            IClusterCommunication communication)
        {
            _logger = logger;
            _snapshotProvider = snapshotProvider;
            _serializer = serializer;
            _runtime = clusterRuntime;
            _communication = communication;
        }

        public async Task HandleAsync(Message message)
        {
            MetricsRequest request;

            try
            {
                request = _serializer.Deserialize<MetricsRequest>(message.Payload);
            }
            catch
            {
                request = new MetricsRequest(); // fallback to default
            }

            var sw = Stopwatch.StartNew();
            var snapshot = _snapshotProvider.CaptureSnapshot(request.DurationSeconds);
            sw.Stop();
            _logger.LogCritical("Captured snapshot in {Elapsed}ms", sw.ElapsedMilliseconds);
            snapshot.TimestampUtc = DateTime.UtcNow;

            var reply = MessageBuilder.Create<ClusterMetricsSnapshot>(_runtime.Self.NodeId, MessageTypes.ClustronMetrics, message.CorrelationId, snapshot);

            var requester = _runtime.PeerManager.GetPeerById(message.SenderId);
            if (requester != null)
            {
                await _communication.Transport.SendAsync(requester, reply);
                _logger.LogDebug("Sent metrics to {NodeId} for last {Duration}s", requester.NodeId, request.DurationSeconds);
            }
        }

    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\MetricsSnapshotReceiverHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Extensions;
using Clustron.Core.Messaging;
using Clustron.Core.Observability;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Handlers;

public class MetricsSnapshotReceiverHandler : IMessageHandler
{
    private readonly ILogger<MetricsSnapshotReceiverHandler> _logger;
    private readonly IEnumerable<IMetricsListener> _listeners;
    private readonly IMessageSerializer _serializer;
    private readonly IClusterRuntime _runtime;

    public string Type => MessageTypes.ClustronMetrics;

    public MetricsSnapshotReceiverHandler(
        IClusterRuntime runtime,
        IEnumerable<IMetricsListener> listeners,
        IMessageSerializer serializer,
        ILogger<MetricsSnapshotReceiverHandler> logger)
    {
        _listeners = listeners;
        _serializer = serializer;
        _runtime = runtime;
        _logger = logger;
    }

    public Task HandleAsync(Message message)
    {
        if(!_runtime.Self.IsMetricsCollector())
            return Task.CompletedTask;

        var snapshot = _serializer.Deserialize<ClusterMetricsSnapshot>(message.Payload);
        if (snapshot == null)
        {
            _logger.LogWarning("Received null metrics snapshot.");
            return Task.CompletedTask;
        }

        foreach (var listener in _listeners)
            listener.OnMetricsReceived(snapshot);

        return Task.CompletedTask;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\NodeJoinedHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Events;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Handlers;
public class NodeJoinedHandler : IMessageHandler
{
    private readonly ILogger<NodeJoinedHandler> _logger;
    private readonly IMessageSerializer _serializer;
    private readonly ClusterPeerManager _peerManager;

    public NodeJoinedHandler(
        ILogger<NodeJoinedHandler> logger,
        IMessageSerializer serializer,
        ClusterPeerManager peerManager)
    {
        _logger = logger;
        _serializer = serializer;
        _peerManager = peerManager;
    }

    public string Type => MessageTypes.NodeJoined;

    public async Task HandleAsync(Message message)
    {
        var joinedEvent = _serializer.Deserialize<NodeJoinedEvent>(message.Payload);

        if (joinedEvent == null || string.IsNullOrEmpty(joinedEvent.Node.NodeId))
        {
            _logger.LogWarning("NodeJoinedHandler received invalid NodeInfo.");
            return;
        }

        // Register peer
        _peerManager.RegisterPeer(joinedEvent.Node);

        // OPTIONAL: If you plan to broadcast or notify later, leave the method async-ready
        await Task.CompletedTask;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handlers\NodeLeftHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Events;
using Clustron.Core.Health;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;
using System.Threading.Tasks;

namespace Clustron.Core.Handlers
{
    public class NodeLeftHandler : IMessageHandler
    {
        private readonly ILogger<NodeLeftHandler> _logger;
        private readonly IMessageSerializer _serializer;
        private readonly ClusterPeerManager _peerManager;
        private readonly IHeartbeatMonitor _heartbeatMonitor;

        public NodeLeftHandler(
            IHeartbeatMonitor heartbeatMonitor,
            IMessageSerializer serializer,
            ClusterPeerManager peerManager,
            ILogger<NodeLeftHandler> logger)
        {
            _serializer = serializer;
            _peerManager = peerManager;
            _logger = logger;
            _heartbeatMonitor = heartbeatMonitor;
        }

        public string Type => MessageTypes.NodeLeft;

        public async Task HandleAsync(Message message)
        {
            var nodeLeftEvent = _serializer.Deserialize<NodeLeftEvent>(message.Payload);

            if (nodeLeftEvent == null || string.IsNullOrWhiteSpace(nodeLeftEvent.Node.NodeId))
            {
                _logger.LogWarning("Received NodeLeft message with null or empty NodeInfo.");
                return;
            }

            var target = nodeLeftEvent.Node;

            _logger.LogWarning("Received NodeLeft notice for {NodeId} from sender {SenderId}", target.NodeId, message.SenderId);

            await _heartbeatMonitor.MarkNodeLeft(target);
        }
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handshake\BasicHandshakeProtocol.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Handshake;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Handshake;

public class BasicHandshakeProtocol : IHandshakeProtocol
{
    private readonly string _localVersion;
    private readonly string _localClusterId;
    private readonly ILogger<BasicHandshakeProtocol> _logger;

    public BasicHandshakeProtocol(string version, string clusterId, ILogger<BasicHandshakeProtocol> logger)
    {
        _localVersion = version;
        _localClusterId = clusterId;
        _logger = logger;
    }

    public Task<HandshakeResult> InitiateHandshakeAsync(NodeInfo targetNode)
    {
        _logger.LogInformation($"Attempting handshake with {targetNode.NodeId}");

        if (targetNode.ClusterId != _localClusterId)
        {
            return Task.FromResult(new HandshakeResult
            {
                Accepted = false,
                Reason = "Cluster ID mismatch"
            });
        }

        if (targetNode.Version != _localVersion)
        {
            return Task.FromResult(new HandshakeResult
            {
                Accepted = false,
                Reason = "Version mismatch"
            });
        }

        return Task.FromResult(new HandshakeResult
        {
            Accepted = true,
            Reason = "Accepted"
        });
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handshake\HandshakeRequest.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Handshake
{
    public class HandshakeRequest
    {
        public string ClusterId { get; set; } = default!;
        public string Version { get; set; } = default!;
        public NodeInfo Sender { get; set; } = default!;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handshake\HandshakeResponse.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Handshake
{
    public class HandshakeResponse
    {
        public bool Accepted { get; set; }
        public string Reason { get; set; } = "";
        public NodeInfo? Leader { get; set; }

        public NodeInfo ResponderNode { get; set; }

        public int LeaderEpoch { get; set; } = 0;
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handshake\IHandshakeProtocol.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Messaging;
using Clustron.Core.Models;

namespace Clustron.Core.Handshake;

public interface IHandshakeProtocol
{
    Task<HandshakeResponse> InitiateHandshakeAsync(NodeInfo targetNode);  // For outbound requests
    Task<HandshakeResponse> ProcessHandshake(HandshakeRequest request); // For inbound handling
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Handshake\TcpHandshakeProtocol.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Cluster.State;
using Clustron.Core.Discovery;
using Clustron.Core.Events;
using Clustron.Core.Handlers;
using Clustron.Core.Handshake;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Handshake;

public class TcpHandshakeProtocol : IHandshakeProtocol
{
    private readonly NodeInfo _self;
    private readonly Lazy<IClusterState> _clusterState;
    private readonly IDiscoveryProvider _discoveryProvider;
    private readonly ILogger<TcpHandshakeProtocol> _logger;
    private readonly IMessageSerializer _serializer;
    private readonly NodeJoinedHandler _nodeJoinedHandler;
    private readonly IClusterCommunication _communication;
    private readonly IClusterRuntime _runtime;

    public TcpHandshakeProtocol(
        IClusterRuntime clusterRuntime,
        IClusterCommunication communication,
        IClusterDiscovery discovery,
        IMessageSerializer serializer,
        Lazy<IClusterState> clusterState,
        NodeJoinedHandler nodeJoinedHandler,
        IClusterLoggerProvider loggerProvider)
    {
        _runtime = clusterRuntime;
        _self = clusterRuntime.Self;
        _communication = communication;
        _discoveryProvider = discovery.DiscoveryProvider;
        _logger = loggerProvider.GetLogger<TcpHandshakeProtocol>();
        _clusterState = clusterState;
        _nodeJoinedHandler = nodeJoinedHandler;
        _serializer = serializer;
    }

    public async Task<HandshakeResponse> InitiateHandshakeAsync(NodeInfo targetNode)
    {
        try
        {
            var request = new HandshakeRequest
            {
                ClusterId = _self.ClusterId,
                Version = _self.Version,
                Sender = _self
            };

            var message = MessageBuilder.Create<HandshakeRequest>(_self.NodeId, MessageTypes.HandshakeRequest, request);

            await _communication.Transport.SendImmediateAsync(targetNode, message);

            var rawResponse = await _communication.Transport.WaitForResponseAsync(
                targetNode.NodeId,
                message.CorrelationId,
                TimeSpan.FromSeconds(5));

            if (rawResponse == null)
            {
                _logger.LogWarning("No handshake response from {NodeId}", targetNode.NodeId);
                return new HandshakeResponse { Accepted = false, Reason = "No response", Leader = null };
            }

            var response = _serializer.Deserialize<HandshakeResponse>(rawResponse.Payload);

            if (response?.Leader != null)
            {
                _clusterState.Value.ForceLeader(response.Leader, response.LeaderEpoch);
            }

            return new HandshakeResponse
            {
                Accepted = response?.Accepted ?? false,
                Reason = response?.Reason ?? "Null response",
                Leader = response?.Leader,
                LeaderEpoch = response?.LeaderEpoch ?? 0,
                ResponderNode = response?.ResponderNode
            };
        }
        catch (Exception ex)
        {
            _logger.LogWarning("Handshake failed with {NodeId}: {Error}", targetNode.NodeId, ex.Message);
            return new HandshakeResponse { Accepted = false, Reason = $"Handshake exception: {ex.Message}" };
        }
    }

    public async Task<HandshakeResponse> ProcessHandshake(HandshakeRequest request)
    {
        var accepted = request.ClusterId == _self.ClusterId && request.Version == _self.Version;
        var reason = accepted ? "Accepted" : "Cluster/Version mismatch";

        if(accepted)
            _runtime.PeerManager.RegisterPeer(request.Sender);

        return new HandshakeResponse
        {
            Accepted = accepted,
            Reason = reason,
            Leader = _clusterState.Value.CurrentLeader,
            LeaderEpoch = _clusterState.Value.CurrentEpoch,
            ResponderNode = _self
        };
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Health\ClusterViewBroadcaster.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;

namespace Clustron.Core.Health;

public class ClusterViewBroadcaster
{
    private readonly ClusterPeerManager _peerManager;
    private readonly IClusterRuntime _runtime;
    private readonly IClusterCommunication _communication;
    private readonly ILogger<ClusterViewBroadcaster> _logger;
    private readonly IMessageSerializer _serializer;
    private readonly TimeSpan _interval = TimeSpan.FromSeconds(30);
    private CancellationTokenSource? _cts;

    public ClusterViewBroadcaster(
        IClusterRuntime runtime,
        IClusterCommunication communication,
        IMessageSerializer serializer,
        ILogger<ClusterViewBroadcaster> logger)
    {
        _runtime = runtime;
        _peerManager = runtime.PeerManager;
        _communication = communication;
        _serializer = serializer;
        _logger = logger;
    }

    public void Start()
    {
        _cts = new CancellationTokenSource();
        Task.Run(() => RunAsync(_cts.Token));
    }

    public void Stop() => _cts?.Cancel();

    private async Task RunAsync(CancellationToken token)
    {
        while (!token.IsCancellationRequested)
        {
            try
            {
                var knownPeers = _peerManager.GetActivePeers()
                    .ToList();

                var payload = new ClusterViewPayload { KnownPeers = knownPeers };
                var message = MessageBuilder.Create<ClusterViewPayload>(_runtime.Self.NodeId, MessageTypes.ClusterView, payload);

                foreach (var peer in knownPeers)
                {
                    try
                    {
                        await _communication.Transport.SendAsync(peer, message);
                        _logger.LogDebug("Sent cluster view to {PeerId}", peer.NodeId);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning("Failed to send cluster view to {PeerId}: {Error}", peer.NodeId, ex.Message);
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("Cluster view broadcast failed: {Error}", ex);
            }

            await Task.Delay(_interval, token);
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Health\HeartbeatNodeTracker.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Events;
using Clustron.Core.Health;
using Clustron.Core.Lifecycle;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;

namespace Clustron.Core.Health
{
    public class HeartbeatNodeTracker
    {
        private readonly IHeartbeatMonitor _heartbeatMonitor;
        private readonly NodeInfo _self;
        private readonly ILogger<HeartbeatNodeTracker> _logger;
        private readonly ConcurrentDictionary<string, bool> _trackedNodes = new();

        public HeartbeatNodeTracker(IClusterEventBus bus, IHeartbeatMonitor monitor, NodeInfo self, IClusterLoggerProvider loggerProvider)
        {
            _heartbeatMonitor = monitor;
            _self = self;
            _logger = loggerProvider.GetLogger<HeartbeatNodeTracker>();

            bus.Subscribe<NodeJoinedEvent>(e =>
            {
                if (e.Node.NodeId != self.NodeId)
                    monitor.AddPeer(e.Node);
            });

            bus.Subscribe<NodeLeftEvent>(e =>
            {
                monitor.RemovePeer(e.Node);
            });
        }

        public async Task OnNodeJoinedAsync(NodeInfo node)
        {
            _logger.LogDebug($"OnNodeJoinedAsync called for Node {node.NodeId}");
            if (node.NodeId == _self.NodeId || _trackedNodes.ContainsKey(node.NodeId))
                return;

            _trackedNodes[node.NodeId] = true;

            _heartbeatMonitor.AddPeer(node);
        }

        public Task OnNodeLeftAsync(NodeInfo node)
        {
            _heartbeatMonitor.RemovePeer(node); 
            _trackedNodes.TryRemove(node.NodeId, out _);
            return Task.CompletedTask;
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Health\IHeartbeatMonitor.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Transport;

namespace Clustron.Core.Health
{
    public interface IHeartbeatMonitor
    {
        Task StartAsync(NodeInfo self, IEnumerable<NodeInfo> peers);
        event Func<NodeInfo, Task> OnNodeFailed;
        //bool IsAlive(string nodeId);
        void AddPeer(NodeInfo peer);
        Task RemovePeer(NodeInfo peer);
        void SetClusterContext(Lazy<ClusterNodeControllerBase> controller, Lazy<ITransport> transport);
        Task MarkNodeLeft(NodeInfo node);
        void MarkHeartbeatReceived(string nodeId);

    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Health\TcpHeartbeatMonitor.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Events;
using Clustron.Core.Health;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Observability;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;

public class TcpHeartbeatMonitor : IHeartbeatMonitor
{
    private readonly ILogger<TcpHeartbeatMonitor> _logger;
    private readonly TimeSpan _interval = TimeSpan.FromSeconds(5);
    private readonly TimeSpan _timeout = TimeSpan.FromSeconds(12);
    private readonly IMessageSerializer _serializer;
    private readonly ClusterPeerManager _peerManager;
    private readonly IMetricContributor _metrics;

    private NodeInfo _self = default!;
    private CancellationTokenSource? _cts;
    private Task? _monitorTask;
    private Lazy<ClusterNodeControllerBase> _clusterLeader;
    private ITransport _transport;

    public event Func<NodeInfo, Task>? OnNodeFailed;

    public TcpHeartbeatMonitor(IClusterRuntime clusterRuntime, IMessageSerializer serializer, IMetricContributor metrics,
                                IClusterLoggerProvider loggerProvider)
    {
        _logger = loggerProvider.GetLogger<TcpHeartbeatMonitor>();
        _serializer = serializer;
        _peerManager = clusterRuntime.PeerManager;
        _metrics = metrics;
    }

    public void SetClusterContext(Lazy<ClusterNodeControllerBase> controller, Lazy<ITransport> transport)
    {
        _clusterLeader = controller;
        _transport = transport.Value;
    }

    public Task StartAsync(NodeInfo self, IEnumerable<NodeInfo> peers)
    {
        _self = self;

        foreach (var peer in peers.Where(p => p.NodeId != self.NodeId))
        {
            _peerManager.RegisterPeer(peer);
        }

        RestartMonitorLoop();
        _logger.LogInformation("Heartbeat monitor started.");
        return Task.CompletedTask;
    }

    public void AddPeer(NodeInfo peer)
    {
        _peerManager.RegisterPeer(peer);
        RestartMonitorLoop();
    }

    public async Task RemovePeer(NodeInfo peer)
    {
        _logger.LogWarning("Attempting to remove peer {NodeId} from monitor", peer.NodeId);

        await _peerManager.TryRemovePeerAsync(peer, async p =>
        {
            bool unreachable = !(await _transport.CanReachNodeAsync(p));
            _logger.LogDebug("Peer {NodeId} reachability check: {Reachable}", p.NodeId, !unreachable);
            return unreachable;
        });

        _transport.RemoveConnection(peer.NodeId);

        if (OnNodeFailed != null)
            await OnNodeFailed.Invoke(peer);
    }

    public async Task MarkNodeLeft(NodeInfo node)
    {
        _logger.LogWarning("Removing node from heartbeat tracking (external event): {NodeId}", node.NodeId);
        await RemovePeer(node);
    }

    public void MarkHeartbeatReceived(string nodeId)
    {
        _metrics.Increment(MetricKeys.Heartbeat.Received);
        _peerManager.MarkHeartbeatReceived(nodeId);
    }

    private void RestartMonitorLoop()
    {
        _cts?.Cancel();
        _cts = new CancellationTokenSource();
        _monitorTask = Task.Run(() => MonitorLoop(_cts.Token));
    }

    private async Task MonitorLoop(CancellationToken token)
    {
        int printInterval = 0;

        while (!token.IsCancellationRequested)
        {
            printInterval++;

            var peersSnapshot = _peerManager
                .GetActivePeers()
                .Where(p => p.NodeId != _self.NodeId)
                .ToList();

            if (printInterval % 50 == 0)
            {
                foreach (var peer in peersSnapshot)
                {
                    var memberInfo = _clusterLeader.Value.CurrentLeader?.NodeId == peer.NodeId ? "Leader" : "Member";
                    _logger.LogDebug("Peer {NodeId} : {Role}", peer.NodeId, memberInfo);
                }
            }

            foreach (var peer in peersSnapshot)
            {
                var missCount = _peerManager.GetMissCount(peer.NodeId);
                _logger.LogDebug("Missed heartbeat count for {NodeId}: {Count}", peer.NodeId, missCount);

                var isAlive = await SendHeartbeatAsync(peer);

                if (isAlive)
                {
                    _logger.LogDebug("Received heartbeat from {NodeId} (ping successful)", peer.NodeId);
                    _peerManager.MarkHeartbeatReceived(peer.NodeId);
                }
                else
                {
                    _peerManager.RecordMissedHeartbeat(peer.NodeId);

                    if (missCount == 1)
                    {
                        _logger.LogWarning("Suspecting node {NodeId} due to missed heartbeat.", peer.NodeId);

                        if (_clusterLeader.Value.CurrentLeader != null)
                        {
                            var hbsuspect = new HeartbeatSuspect(peer);
                            var msg = MessageBuilder.Create<HeartbeatSuspect>(_self.NodeId, MessageTypes.HeartbeatSuspect, hbsuspect);
                            _ = _transport.SendAsync(_clusterLeader.Value.CurrentLeader, msg);
                        }
                    }

                    if (_peerManager.HasTimedOut(peer.NodeId, _timeout) && _peerManager.IsAlive(peer.NodeId))
                    {
                        _logger.LogWarning("Node failed after timeout: {NodeId}", peer.NodeId);
                        await RemovePeer(peer);
                        await _transport.HandlePeerDownAsync(peer.NodeId);
                    }
                }
            }

            try
            {
                await Task.Delay(_interval, token);
            }
            catch (TaskCanceledException)
            {
                return;
            }
        }
    }

    private async Task<bool> SendHeartbeatAsync(NodeInfo node)
    {
        try
        {
            var heartbeatPayload = new HeartbeatPayload
            {
                LeaderId = _clusterLeader.Value.CurrentLeader.NodeId,
                LeaderEpoch = _clusterLeader.Value.CurrentEpoch
            };

            var correlationId = Guid.NewGuid().ToString();
            var message = MessageBuilder.Create(_self.NodeId, MessageTypes.Heartbeat, correlationId, heartbeatPayload);

            await _transport!.SendAsync(node, message);
            _metrics.Increment(MetricKeys.Heartbeat.Sent);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogDebug("Failed to send heartbeat to {NodeId}: {Error}", node.NodeId, ex.Message);
            return false;
        }
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Helpers\ClustronRoles.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Configuration;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Helpers
{
    public static class ClustronRolesHelpers
    {

        public static bool IsMetricsOnly(this ClustronConfig config)
        {
            return config.Roles?.Contains(ClustronRoles.MetricsCollector, StringComparer.OrdinalIgnoreCase) == true;
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Helpers\LazyResolver.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Microsoft.Extensions.DependencyInjection;

namespace Clustron.Core.Helpers;
public class LazyResolver<T> : Lazy<T> where T : class
{
    public LazyResolver(IServiceProvider provider)
        : base(() => provider.GetRequiredService<T>())
    {
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Helpers\RetryHelper.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Microsoft.Extensions.Logging;

namespace Clustron.Core.Helpers;
public static class RetryHelper
{
    public static async Task<T?> RetryAsync<T>(Func<Task<T>> action, int maxAttempts, int backoffMillis, ILogger? logger = null)
    {
        for (int attempt = 1; attempt <= maxAttempts; attempt++)
        {
            try
            {
                return await action();
            }
            catch (Exception ex)
            {
                if (attempt == maxAttempts)
                    throw;

                logger?.LogWarning("Retry {Attempt} failed: {Message}", attempt, ex.Message);
                await Task.Delay(backoffMillis * attempt); // Exponential backoff
            }
        }

        return default;
    }

    public static async Task RetryAsync(Func<Task> action, int maxAttempts, int backoffMillis, ILogger? logger = null)
    {
        await RetryAsync(async () => { await action(); return true; }, maxAttempts, backoffMillis, logger);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Hosting\ClusterViewLogger.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Configuration;
using Clustron.Core.Models;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Clustron.Core.Hosting;
public class ClusterViewLogger : IHostedService, IDisposable
{
    private readonly ILogger<ClusterViewLogger> _logger;
    private readonly ClusterPeerManager _peerManager;
    private readonly ClusterNodeControllerBase _leader;
    private readonly NodeInfo _self;
    private readonly int _intervalSeconds;
    private Timer? _timer;

    public ClusterViewLogger(
        ILogger<ClusterViewLogger> logger,
        IOptions<ClustronConfig> options, ClusterPeerManager peerManager,
        ClusterNodeControllerBase clusterLeader)
    {
        _logger = logger;
        _peerManager = peerManager;
        _leader = clusterLeader;
        _self = peerManager.Self;
        _intervalSeconds = options.Value.LogClusterViewIntervalSeconds;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        if (_intervalSeconds > 0)
        {
            _timer = new Timer(LogClusterView, null, TimeSpan.Zero, TimeSpan.FromSeconds(_intervalSeconds));
        }
        return Task.CompletedTask;
    }

    private void LogClusterView(object? state)
    {
        var peers = _peerManager.GetActivePeers();
        var leader = _leader.CurrentLeader?.NodeId ?? "<none>";
        _logger.LogInformation("Cluster View from {NodeId}: ActivePeers=[{Peers}] Leader={Leader} Epoch={Epoch}",
            _self.NodeId,
            string.Join(", ", peers.Select(p => p.NodeId)),
            leader, _leader.CurrentEpoch);
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        _timer?.Change(Timeout.Infinite, 0);
        return Task.CompletedTask;
    }

    public void Dispose() => _timer?.Dispose();
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Hosting\ClustronNodeHost.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Lifecycle;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;
using System.Threading.Tasks;

namespace Clustron.Core.Hosting
{
    public class ClustronNodeHost
    {
        private readonly ClusterNodeControllerBase _controller;
        private readonly ILogger<ClustronNodeHost> _logger;
        private readonly ITransport _transport;
        private readonly IMessageRouter _router;

        public ClustronNodeHost(
            ClusterNodeControllerBase controller,
            ITransport transport,
            IMessageRouter router,
            ILogger<ClustronNodeHost> logger)
        {
            _controller = controller;
            _transport = transport;
            _router = router;
            _logger = logger;
        }

        public async Task StartAsync()
        {
            _logger.LogInformation("Starting Clustron node...");

            await _transport.StartAsync(_router);
            await Task.Delay(500);
            await _controller.StartAsync();
        }

        public Task StopAsync()
        {
            _logger.LogInformation("Stopping Clustron node...");
            return Task.CompletedTask;
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Hosting\ClustronStartupService.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Microsoft.Extensions.Hosting;
using System.Threading;
using System.Threading.Tasks;

namespace Clustron.Core.Hosting;

public class ClustronStartupService : IHostedService
{
    private readonly ClustronNodeHost _nodeHost;

    public ClustronStartupService(ClustronNodeHost nodeHost)
    {
        _nodeHost = nodeHost;
    }

    public Task StartAsync(CancellationToken cancellationToken)
    {
        return _nodeHost.StartAsync(); // this should initialize the node
    }

    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Hosting\InternalServiceRegistration.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Cluster.Behaviors;
using Clustron.Core.Cluster.State;
using Clustron.Core.Configuration;
using Clustron.Core.Discovery;
using Clustron.Core.Election;
using Clustron.Core.Events;
using Clustron.Core.Handlers;
using Clustron.Core.Handshake;
using Clustron.Core.Health;
using Clustron.Core.Hosting;
using Clustron.Core.Lifecycle;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Observability;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Net;

namespace Clustron.Core.Hosting;
public static class InternalServiceRegistration
{
    public static IServiceCollection AddClustronCoreServices(
    this IServiceCollection services,
    ClustronConfig config,
    NodeInfo self,
    ILoggerFactory loggerFactory)
    {
        // Core service configuration
        services.Configure<ClustronConfig>(opts => {
            opts.ClusterId = config.ClusterId;
            opts.Version = config.Version;
            opts.Port = config.Port;
            opts.Roles = config.Roles;
            opts.RetryOptions = config.RetryOptions;
            opts.StaticNodes = config.StaticNodes;
            opts.UseDuplexConnections = config.UseDuplexConnections;
        });

        services.AddSingleton(sp => sp.GetRequiredService<IOptions<ClustronConfig>>().Value);
        services.AddSingleton(self);
        services.AddSingleton(loggerFactory);

        var serializer = new MessagePackSerializerAdapter();
        MessageBuilder.Configure(serializer);

        //For disruptor queue
        IClusterEventBus eventBus = new AsyncClusterEventBus(loggerFactory.CreateLogger<AsyncClusterEventBus>()
                           , serializer, handler => new DisruptorEventQueue<IClusterEvent>(e => handler(e)));


        //For channel queue
        //IClusterEventBus eventBus = new AsyncClusterEventBus(loggerFactory.CreateLogger<AsyncClusterEventBus>()
        //                    , serializer);

        services.AddSingleton<IClusterEventBus>(eventBus);

        var discoveryProvider = new AdaptiveDiscoveryProvider(config.StaticNodes ?? []);
        var nullTransport = new NullTransport();
        var peerRegistry = new PeerRegistry(self, discoveryProvider);
        var peerManager = new ClusterPeerManager(peerRegistry, eventBus, loggerFactory.CreateLogger<ClusterPeerManager>());


        services.AddSingleton<IMessageSerializer>(serializer);
        services.AddSingleton<IDiscoveryProvider>(discoveryProvider);
        services.AddSingleton(peerRegistry);

        services.AddSingleton<ClusterPeerManager>();

        var context = new ClusterContext(self, nullTransport, discoveryProvider, peerManager, eventBus, config, loggerFactory);
        services.AddSingleton(context);
        services.AddSingleton<IClusterRuntime>(sp => sp.GetRequiredService<ClusterContext>());
        services.AddSingleton<IClusterLoggerProvider>(sp => sp.GetRequiredService<ClusterContext>());
        services.AddSingleton<IClusterCommunication>(sp => sp.GetRequiredService<ClusterContext>());
        services.AddSingleton<IClusterDiscovery>(sp => sp.GetRequiredService<ClusterContext>());
        services.AddSingleton<IElectionCoordinatorProvider>(sp => sp.GetRequiredService<ClusterContext>());

        eventBus.Configure(context, self);

        services.AddSingleton<IElectionStrategy>(sp =>
                new BullyElectionStrategy(
                    sp.GetRequiredService<IClusterRuntime>(),
                    sp.GetRequiredService<IClusterLoggerProvider>(),
                    TimeSpan.FromSeconds(3)) // or bind this from config
        );


        services.AddSingleton<ElectionCoordinator>(sp =>
        {
            var coordinator = new ElectionCoordinator(self,
            sp.GetRequiredService<IElectionStrategy>(),
            sp.GetRequiredService<ILogger<ElectionCoordinator>>());

            context.SetElectionCoordinatory(coordinator);

            return coordinator;
        });

        services.AddSingleton(context);

        // Core metrics infrastructure
        services.AddSingleton<IMetricContributor, DefaultMessageStatsProvider>();
        services.AddSingleton<IMetricsSnapshotProvider>(sp => (IMetricsSnapshotProvider)sp.GetRequiredService<IMetricContributor>());


        // Transport and routing
        services.AddSingleton<ITransportFactory, TransportFactory>();
        services.AddSingleton<ITransport>(sp => sp.GetRequiredService<ITransportFactory>().Create());
        services.AddSingleton<IMessageRouter, ClusterMessageRouter>();

        services.AddSingleton<IHeartbeatMonitor>(sp =>
        {
            var context = sp.GetRequiredService<ClusterContext>();
            var serializer = sp.GetRequiredService<IMessageSerializer>();
            var metrics = sp.GetRequiredService<IMetricContributor>();

            var monitor = new TcpHeartbeatMonitor(
                                context,                         // IClusterRuntime
                                serializer,                      // IMessageSerializer
                                metrics,                           // IMessageStatsProvider
                                context                          // IClusterLoggerProvider
                            );

            var controller = new Lazy<ClusterNodeControllerBase>(() => sp.GetRequiredService<ClusterNodeControllerBase>());
            var transport = new Lazy<ITransport>(() => sp.GetRequiredService<ITransport>());

            monitor.SetClusterContext(controller, transport);
            return monitor;
        });


        services.AddSingleton<NodeJoinedHandler>(sp =>
            new NodeJoinedHandler(
                sp.GetRequiredService<ILogger<NodeJoinedHandler>>(),
                serializer,
                sp.GetRequiredService<ClusterPeerManager>()));

        services.AddSingleton<IHandshakeProtocol>(sp =>
                new TcpHandshakeProtocol(
                    context, context, context,
                    serializer,
                    new Lazy<IClusterState>(() => sp.GetRequiredService<IClusterState>()),
                    sp.GetRequiredService<NodeJoinedHandler>(),
                    context));


        services.AddSingleton<JoinManager>();
        services.AddSingleton<MessageDeduplicationCache>();


        services.AddSingleton<ILeaderElectionService, LeaderElectionService>();

        services.AddSingleton<HeartbeatMonitorBehavior>();
        services.AddSingleton<MetricsCollectorBehavior>();
        services.AddSingleton<ElectionBehavior>();

        services.AddSingleton<IRoleAwareBehavior, MetricsCollectorBehavior>();
        services.AddSingleton<IMetricsListener, MetricsCollectorBehavior>();

        services.AddSingleton<IRoleAwareBehavior, ElectionCoordinatorBehavior>();

        services.AddSingleton<ElectionCoordinatorBehavior>();
        services.AddSingleton<IRoleAwareBehavior, ClusterViewBroadcasterBehavior>();
        services.AddSingleton<ClusterViewBroadcasterBehavior>();

        services.AddSingleton<ClusterNodeControllerBase>(sp => {
            var roles = self.Roles ?? [];

            // Use Lazy to defer actual resolution until after DI builds the graph
            var behaviorFactories = new Dictionary<string, Func<IRoleAwareBehavior>>
            {
                ["HeartbeatMonitor"] = () => sp.GetRequiredService<HeartbeatMonitorBehavior>(),
                ["Election"] = () => sp.GetRequiredService<ElectionBehavior>(),
                ["MetricsCollector"] = () => sp.GetRequiredService<MetricsCollectorBehavior>(),
                ["ElectionCoordinator"] = () => sp.GetRequiredService<ElectionCoordinatorBehavior>(),
                ["ClusterViewBroadcaster"] = () => sp.GetRequiredService<ClusterViewBroadcasterBehavior>(),
            };

            var selectedBehaviors = behaviorFactories.Values
                .Select(factory => new Lazy<IRoleAwareBehavior>(factory))
                .ToList();

            return new RoleAwareClusterController(
                context,
                sp.GetRequiredService<JoinManager>(),
                context,
                sp.GetRequiredService<IHeartbeatMonitor>(),
                selectedBehaviors.Select(lazy => lazy.Value),
                context);
        });


        services.AddSingleton<IClusterState>(sp => sp.GetRequiredService<ClusterNodeControllerBase>());
        services.AddSingleton<IClusterStateMutator>(sp => sp.GetRequiredService<ClusterNodeControllerBase>());


        // Host and message handlers
        services.AddSingleton<ClustronNodeHost>();

        services.AddSingleton<IMessageHandler, MetricsSnapshotReceiverHandler>();
        services.AddSingleton<IMessageHandler, HandshakeRequestHandler>();
        services.AddSingleton<IMessageHandler, HandshakeResponseHandler>();
        services.AddSingleton<IMessageHandler, LeaderChangedHandler>();
        services.AddSingleton<IMessageHandler, HeartbeatHandler>();
        services.AddSingleton<IMessageHandler, HeartbeatSuspectHandler>();
        services.AddSingleton<IMessageHandler>(sp => sp.GetRequiredService<NodeJoinedHandler>());
        services.AddSingleton<IMessageHandler, NodeLeftHandler>(sp =>
            new NodeLeftHandler(
                sp.GetRequiredService<IHeartbeatMonitor>(),
                serializer,
                sp.GetRequiredService<ClusterPeerManager>(),
                sp.GetRequiredService<ILogger<NodeLeftHandler>>()));

        services.AddSingleton<IMessageHandler, MetricsRequestHandler>();
        services.AddSingleton<IMessageHandler, ClusterViewHandler>();

        return services;
    }

    public static IServiceCollection Register(
    this IServiceCollection services,
    ClustronConfig config,
    ILoggerFactory loggerFactory)
    {
        string ip = Dns.GetHostEntry(Dns.GetHostName())
            .AddressList
            .FirstOrDefault(a => a.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)?
            .ToString() ?? "127.0.0.1";

        var self = new NodeInfo
        {
            ClusterId = config.ClusterId,
            Version = config.Version,
            Host = ip,
            Port = config.Port,
            NodeId = $"{config.ClusterId}-{ip.Replace(".", "_")}-{config.Port}",
            Roles = config.Roles 
        };

        if (config.StaticNodes != null)
        {
            foreach (var peer in config.StaticNodes)
            {
                peer.ClusterId = config.ClusterId;
                peer.Version = config.Version;
                peer.NodeId = $"{peer.ClusterId}-{peer.Host.Replace(".", "_")}-{peer.Port}";
            }
        }

        return services.AddClustronCoreServices(config, self, loggerFactory);
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Lifecycle\INodeLifecycleListener.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

namespace Clustron.Core.Lifecycle
{
    using Clustron.Core.Models;
    using System.Threading.Tasks;

    public interface INodeLifecycleListener
    {
        Task OnNodeJoinedAsync(NodeInfo node);
        Task OnNodeLeftAsync(NodeInfo node);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Lifecycle\LoggerNodeLifecycleListener.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Events;
using Clustron.Core.Lifecycle;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;
using System.Threading.Tasks;

namespace Clustron.Core.Lifecycle
{
    public class LoggingNodeLifecycleListener
    {
        private readonly ILogger<LoggingNodeLifecycleListener> _logger;

        public LoggingNodeLifecycleListener(IClusterEventBus bus, ILogger<LoggingNodeLifecycleListener> logger)
        {
            _logger = logger;

            bus.Subscribe<NodeJoinedEvent>(e => _logger.LogInformation("Node joined: {NodeId}", e.Node.NodeId));
            bus.Subscribe<NodeLeftEvent>(e => _logger.LogWarning("Node left: {NodeId}", e.Node.NodeId));
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Lifecycle\NodeLifecycleBroadcaster.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Lifecycle;
using Clustron.Core.Models;
using System.Collections.Concurrent;

public class NodeLifecycleBroadcaster
{
    private readonly List<INodeLifecycleListener> _listeners = new();
    private readonly ConcurrentDictionary<string, bool> _activeNodes = new();

    public void AddListener(INodeLifecycleListener listener)
    {
        if (!_listeners.Contains(listener))
            _listeners.Add(listener);
    }

    public IEnumerable<INodeLifecycleListener> Listeners => _listeners;

    public async Task NotifyNodeJoinedAsync(NodeInfo node)
    {
        // Only notify if node isn't currently marked as active
        if (_activeNodes.ContainsKey(node.NodeId))
            return;

        _activeNodes[node.NodeId] = true;

        foreach (var listener in _listeners)
            await listener.OnNodeJoinedAsync(node);
    }

    public async Task NotifyNodeLeftAsync(NodeInfo node)
    {
        // Only notify if node was active
        if (!_activeNodes.TryRemove(node.NodeId, out _))
            return;

        foreach (var listener in _listeners)
            await listener.OnNodeLeftAsync(node);
    }

    public bool IsNodeActive(string nodeId) => _activeNodes.ContainsKey(nodeId);
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Messaging\ClusterMessageRouter.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Messaging;
using Clustron.Core.Observability;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;

namespace Clustron.Core.Messaging;

public class ClusterMessageRouter : IMessageRouter
{
    private readonly ConcurrentDictionary<string, IMessageHandler> _handlerMap = new();
    private readonly IMetricContributor _metrics;
    private readonly ILogger<ClusterMessageRouter> _logger;

    public ClusterMessageRouter(IEnumerable<IMessageHandler> handlers, IMetricContributor metrics, ILogger<ClusterMessageRouter> logger)
    {
        _metrics = metrics;
        _logger = logger;

        foreach (var handler in handlers)
        {
            if (_handlerMap.TryAdd(handler.Type, handler))
            {
                _logger.LogDebug("Registered handler for {MessageType}: {HandlerType}", handler.Type, handler.GetType().FullName);
            }
            else
            {
                _logger.LogWarning("Duplicate handler detected for message type {MessageType}", handler.Type);
            }
        }

        _logger.LogDebug("ClusterMessageRouter initialized with {Count} message handlers.", _handlerMap.Count);
    }

    public Task AddHandler(IMessageHandler handler)
    {
        if (_handlerMap.TryAdd(handler.Type, handler))
        {
            _logger.LogInformation("Dynamically added handler for {MessageType}: {HandlerType}",
                handler.Type, handler.GetType().FullName);
        }
        else
        {
            _logger.LogWarning("Handler already exists for message type: {MessageType}", handler.Type);
        }

        return Task.CompletedTask;
    }

    public async Task RouteAsync(Message message)
    {
        if (string.IsNullOrWhiteSpace(message.TypeInfo))
        {
            _logger.LogError("Cannot route message with null TypeInfo. CorrelationId={CorrelationId}, Type={Type}", message.CorrelationId, message.TypeInfo);
            return;
        }

        if (_handlerMap.TryGetValue(message.MessageType, out var handler))
        {
            try
            {
                await handler.HandleAsync(message);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error while handling message of type {Type} from {Sender}", message.MessageType, message.SenderId);
            }
        }
        else
        {
            _logger.LogWarning("No handler found for message type: {Type}", message.MessageType);
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Messaging\IMessageHandler.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;

namespace Clustron.Core.Messaging
{
    public interface IMessageHandler
    {
        string Type { get; }
        Task HandleAsync(Message rawMessage);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Messaging\IMessageRouter.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Messaging;

public interface IMessageRouter
{
    Task RouteAsync(Message message);
    Task AddHandler(IMessageHandler handler);
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Messaging\MessageBuilder.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;

namespace Clustron.Core.Messaging;

public static class MessageBuilder
{
    private static IMessageSerializer? _serializer;

    public static void Configure(IMessageSerializer serializer)
    {
        _serializer = serializer;
    }

    public static Message Create<T>(string senderId, string type, T payload)
    {
        return Create<T>(senderId, type, Guid.NewGuid().ToString(), payload);
    }

    public static Message Create<T>(string senderId, string type, string correlationId, T payload)
    {
        if (_serializer == null)
            throw new InvalidOperationException("MessageBuilder serializer not configured.");

        if (string.IsNullOrWhiteSpace(correlationId))
            throw new ArgumentException("CorrelationId must be provided.", nameof(correlationId));

        // Prevent T being object to enforce generic typing
        if (typeof(T) == typeof(object))
            throw new InvalidOperationException("Generic type T must be specified explicitly while creating Message.");


        var actualType = payload?.GetType() ?? typeof(T);

        return new Message
        {
            MessageType = type,
            SenderId = senderId,
            CorrelationId = correlationId,
            TypeInfo = actualType.AssemblyQualifiedName
    ?? throw new InvalidOperationException($"Unable to determine TypeInfo for payload of type {actualType}. This usually happens if payload is null and T is object or generic."),

            Payload = _serializer.Serialize(actualType, payload!)
        };
    }

    //public static Message LeaderChanged(NodeInfo leader, int epoch)
    //{
    //    if (_serializer == null)
    //        throw new InvalidOperationException("MessageBuilder is not configured with a serializer.");

    //    return new Message
    //    {
    //        MessageType = MessageTypes.LeaderChanged,
    //        SenderId = leader.NodeId,
    //        Payload = _serializer.Serialize(leader)
    //    };
    //}

    //public static T DeserializePayload<T>(byte[] payload)
    //{
    //    if (_serializer == null)
    //        throw new InvalidOperationException("MessageBuilder serializer not configured.");

    //    return _serializer.Deserialize<T>(payload);
    //}
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Messaging\MessageDeduplicationCache.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Messaging
{
    public class MessageDeduplicationCache
    {
        private readonly ConcurrentDictionary<Guid, DateTime> _seen = new();
        private readonly TimeSpan _window;
        private readonly Timer _cleanupTimer;

        public MessageDeduplicationCache(TimeSpan? window = null)
        {
            _window = window ?? TimeSpan.FromMinutes(2);
            _cleanupTimer = new Timer(Cleanup, null, _window, _window);
        }

        public bool IsDuplicate(Guid id)
        {
            var now = DateTime.UtcNow;
            return !_seen.TryAdd(id, now);
        }

        private void Cleanup(object? _)
        {
            var threshold = DateTime.UtcNow - _window;
            foreach (var kvp in _seen)
            {
                if (kvp.Value < threshold)
                    _seen.TryRemove(kvp.Key, out var _);
            }
        }
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Messaging\MessageTypes.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

namespace Clustron.Core.Messaging
{
    public static class MessageTypes
    {
        public const string HandshakeRequest = "clustron.handshake.request";
        public const string HandshakeResponse = "clustron.handshake.response";
        public const string LeaderChanged = "clustron.leader.changed";
        public const string NodeJoined = "clustron.node.joined";
        public const string NodeLeft = "clustron.node.left";
        public const string Heartbeat = "clustron.heartbeat";
        public const string HeartbeatSuspect = "clustron.heartbeat.suspect";
        public const string ClustronMetrics = "clustron.metrics"; 
        public const string RequestMetrics = "clustron.metrics.request";
        public const string ClusterView = "clustron.cluster.view";
        public const string CustomEvent = "clustron.custom.event";
        public const string ClientMessage = "clustron.message.client";
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Models\ClusterViewPayload.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Models
{
    public class ClusterViewPayload
    {
        public List<NodeInfo> KnownPeers { get; set; } = new();
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Models\HeartbeatPayload.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

namespace Clustron.Core.Models;

public class HeartbeatPayload
{
    public string? LeaderId { get; set; }
    public int LeaderEpoch { get; set; }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Models\MetricsRequest.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Models
{
    public class MetricsRequest
    {
        public int DurationSeconds { get; set; } = 60; // default to 60 if not specified
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Models\NodeInfo.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

namespace Clustron.Core.Models;

public class NodeInfo
{
    public string NodeId { get; set; }
    public string Host { get; set; } = "localhost";
    public int Port { get; set; } = 4000;
    public string ClusterId { get; set; } = "default-cluster";
    public string Version { get; set; } = "1.0.0";
    public List<string> Roles { get; set; } = new();
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Observability\ClusterMetricsReceiver.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Observability;

public class ClusterMetricsReceiver : IMetricsListener
{
    private readonly ILogger<ClusterMetricsReceiver> _logger;
    private readonly ConcurrentBag<IMetricsListener> _listeners = new();

    public ClusterMetricsReceiver(ILogger<ClusterMetricsReceiver> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// This method is invoked by MetricsMessageHandler when a new metrics message arrives.
    /// </summary>
    public void OnMetricsReceived(ClusterMetricsSnapshot metrics)
    {
        _logger.LogDebug("Received metrics from node {NodeId} at {Timestamp}", metrics.NodeId, metrics.TimestampUtc);

        foreach (var listener in _listeners)
        {
            try
            {
                listener.OnMetricsReceived(metrics);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error while dispatching metrics to listener.");
            }
        }
    }

    public void RegisterListener(IMetricsListener listener)
    {
        _listeners.Add(listener);
        _logger.LogDebug("Registered IMetricsListener: {Type}", listener.GetType().FullName);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Observability\DefaultMessageStatsProvider.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Configuration;
using Clustron.Core.Models;
using System.Linq;
using System.Threading;

namespace Clustron.Core.Observability;

public class DefaultMessageStatsProvider : IMetricContributor, IMetricsSnapshotProvider
{
    private readonly RollingMetricsRegistry _metrics;
    private readonly ClusterPeerManager _peerManager;
    private readonly IClusterRuntime _clusterRuntime;

    public DefaultMessageStatsProvider(IClusterRuntime clusterRuntime)
    {
        _clusterRuntime = clusterRuntime;
        _peerManager = clusterRuntime.PeerManager;
        _metrics = new RollingMetricsRegistry(clusterRuntime.Configuration.Metrics.RollingWindowSeconds);
    }

    public void Increment(string key) => _metrics.Increment(key);

    public long GetTotal(string key) => _metrics.GetTotal(key);

    public int[] GetPerSecondRates(string key, int seconds) => _metrics.GetPerSecondRates(key, seconds);

    public ClusterMetricsSnapshot CaptureSnapshot(int durationSeconds)
    {
        var snapshot = _metrics.CaptureSnapshot(durationSeconds);
        snapshot.NodeId = _clusterRuntime.Self.NodeId;
        snapshot.TimestampUtc = DateTime.UtcNow;
        snapshot.ActiveConnections = _peerManager.GetActivePeers().Count();
        return snapshot;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Observability\IMetricContributor.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

namespace Clustron.Core.Observability;

public interface IMetricContributor
{
    void Increment(string metricKey);
    long GetTotal(string metricKey);
    int[] GetPerSecondRates(string metricKey, int seconds);
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Observability\RollingCounter.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

namespace Clustron.Core.Observability;

public class RollingCounter
{
    private readonly int[] _buffer;
    private readonly int _windowSize;
    private int _index = 0;
    private int _currentSecondCount = 0;
    private DateTime _lastSecond;
    private readonly object _lock = new();
    private long _totalSinceStart = 0;

    public RollingCounter(int windowSize)
    {
        _windowSize = windowSize;
        _buffer = new int[windowSize];
        _lastSecond = DateTime.UtcNow;
    }

    public void Increment()
    {
        lock (_lock)
        {
            Flush();
            _currentSecondCount++;
            _totalSinceStart++;
        }
    }

    private void Flush()
    {
        var now = DateTime.UtcNow;
        int elapsedSeconds = (int)(now - _lastSecond).TotalSeconds;

        if (elapsedSeconds <= 0)
            return;

        for (int i = 0; i < elapsedSeconds; i++)
        {
            _index = (_index + 1) % _windowSize;
            _buffer[_index] = 0;
        }
        _buffer[_index] = _currentSecondCount;

        _lastSecond = _lastSecond.AddSeconds(elapsedSeconds);
        _currentSecondCount = 0;
    }

    public int[] GetPerSecondRates(int seconds)
    {
        lock (_lock)
        {
            Flush();

            if (seconds <= 0 || seconds > _windowSize)
                throw new ArgumentOutOfRangeException(nameof(seconds), $"Must be between 1 and {_windowSize}");

            // Return the most recent `seconds` values (oldest to newest)
            return Enumerable.Range(_windowSize - seconds, seconds)
                .Select(i => _buffer[(_index + 1 + i) % _windowSize])
                .ToArray();
        }
    }

    public long Total()
    {
        lock (_lock)
        {
            return _totalSinceStart;
        }
    }
}




// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Observability\RollingMetricsRegistry.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using System.Collections.Concurrent;

namespace Clustron.Core.Observability;

public class RollingMetricsRegistry : IMetricsSnapshotProvider
{
    private readonly ConcurrentDictionary<string, RollingCounter> _counters = new();
    private readonly int _windowSize;

    public RollingMetricsRegistry(int windowSize)
    {
        _windowSize = windowSize;
    }

    public void Increment(string key)
    {
        var counter = _counters.GetOrAdd(key, _ => new RollingCounter(_windowSize));
        counter.Increment();
    }

    public long GetTotal(string key)
    {
        if (_counters.TryGetValue(key, out var counter))
        {
            return counter.Total();
        }
        return 0;
    }

    public int[] GetPerSecondRates(string key, int seconds)
    {
        if (_counters.TryGetValue(key, out var counter))
        {
            return counter.GetPerSecondRates(seconds);
        }
        return Enumerable.Repeat(0, seconds).ToArray();
    }

    public ClusterMetricsSnapshot CaptureSnapshot(int seconds)
    {
        var snapshot = new ClusterMetricsSnapshot
        {
            TimestampUtc = DateTime.UtcNow,
            Totals = new Dictionary<string, long>(),
            PerSecondRates = new Dictionary<string, int[]>()
        };

        foreach (var kvp in _counters)
        {
            snapshot.Totals[kvp.Key] = kvp.Value.Total();
            snapshot.PerSecondRates[kvp.Key] = kvp.Value.GetPerSecondRates(seconds);
        }

        return snapshot;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Serialization\IMessageSerializer.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;

namespace Clustron.Core.Serialization;
public interface IMessageSerializer
{
    byte[] Serialize<T>(T obj);
    byte[] Serialize(Type type, object value);
    T Deserialize<T>(byte[] data);
    T Deserialize<T>(ReadOnlySpan<byte> data);

    object Deserialize(byte[] data, Type type);
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Serialization\JsonMessageSerializer.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Text.Json;


namespace Clustron.Core.Serialization
{
    public class JsonMessageSerializer : IMessageSerializer
    {
        private readonly JsonSerializerOptions _options = new(JsonSerializerDefaults.Web)
        {
            PropertyNameCaseInsensitive = true
        };
        public byte[] Serialize<T>(T obj) =>
            JsonSerializer.SerializeToUtf8Bytes(obj, _options);

        public byte[] Serialize(Type type, object value) =>
    JsonSerializer.SerializeToUtf8Bytes(value, type, _options);

        public T Deserialize<T>(byte[] data) =>
            JsonSerializer.Deserialize<T>(data, _options)!;

        //public T Deserialize<T>(byte[] data)
        //{
        //    var json = Encoding.UTF8.GetString(data);
        //    Console.WriteLine("[Deserialize<T>] " + json); // Debug only
        //    return JsonSerializer.Deserialize<T>(data, _options)!;
        //}

        public object Deserialize(byte[] data, Type type) =>
            JsonSerializer.Deserialize(data, type)!;

        public T Deserialize<T>(ReadOnlySpan<byte> data) =>
            JsonSerializer.Deserialize<T>(data, _options)!;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Serialization\MessagePackSerializerAdapter.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using MessagePack;
using MessagePack.Resolvers;
using System;
using System.Buffers;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace Clustron.Core.Serialization
{
    public class MessagePackSerializerAdapter : IMessageSerializer
    {
        private static readonly MessagePackSerializerOptions _options =
            MessagePackSerializerOptions.Standard.WithResolver(ContractlessStandardResolver.Instance);
        
        public byte[] Serialize<T>(T obj) =>
            MessagePackSerializer.Serialize(obj, _options);

        public byte[] Serialize(Type type, object value) =>
            MessagePackSerializer.Serialize(type, value, _options);

        public T Deserialize<T>(byte[] data) =>
            MessagePackSerializer.Deserialize<T>(data, _options);

        public T Deserialize<T>(ReadOnlySpan<byte> data)
        {
            var memory = new ReadOnlyMemory<byte>(data.ToArray()); // causes allocation
            var sequence = new ReadOnlySequence<byte>(memory);
            var reader = new MessagePackReader(sequence);
            return MessagePackSerializer.Deserialize<T>(ref reader, _options);
        }

        public object Deserialize(byte[] data, Type type) =>
            MessagePackSerializer.Deserialize(type, data, _options);

    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Transport\BaseTcpTransport.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;
using System.Collections.Immutable;

namespace Clustron.Core.Transport;

public abstract class BaseTcpTransport : ITransport
{
    protected readonly ILogger _logger;
    protected readonly IMessageSerializer _serializer;
    protected readonly ClusterPeerManager _peerManager;
    protected readonly ConcurrentDictionary<string, PersistentConnection> _connections = new();

    protected readonly ConcurrentDictionary<string, TaskCompletionSource<Message>> _responseAwaiters = new();
    protected readonly ConcurrentDictionary<string, SemaphoreSlim> _sendLocks = new();
    Timer _timer;

    protected BaseTcpTransport(
        IClusterRuntime clusterRuntime,
        IMessageSerializer serializer, ILogger logger)
    {
        _peerManager = clusterRuntime.PeerManager;
        _serializer = serializer;

        _logger = logger;

        _timer = new Timer(_ => CleanupIdleConnections(TimeSpan.FromMinutes(1)), null, TimeSpan.Zero, TimeSpan.FromSeconds(30));
    }

    public abstract Task StartAsync(IMessageRouter router);
    public abstract Task SendAsync(NodeInfo target, Message message);

    public abstract Task SendAsync(NodeInfo target, byte[] data);
    public abstract void RemoveConnection(string nodeId);
    public abstract Task<bool> CanReachNodeAsync(NodeInfo node);

    public virtual async Task BroadcastAsync(Message message, params string[] roles)
    {
        var peers = _peerManager.GetPeersWithRole(roles);
        var body = _serializer.Serialize(message);

        var tasks = new List<Task>();

        foreach (var peer in peers)
        {
            if (peer.NodeId == message.SenderId)
                continue;

            tasks.Add(SendSafeAsync(peer, body));
        }

        await Task.WhenAll(tasks);
    }

    public virtual Task<Message> WaitForResponseAsync(string expectedSenderId, string correlationId, TimeSpan timeout)
    {
        var tcs = new TaskCompletionSource<Message>(TaskCreationOptions.RunContinuationsAsynchronously);
        _responseAwaiters[correlationId] = tcs;

        var cts = new CancellationTokenSource(timeout);
        CancellationTokenRegistration registration = cts.Token.Register(() =>
        {
            if (_responseAwaiters.TryRemove(correlationId, out var existing))
            {
                existing.TrySetCanceled();
            }
        });

        // When the task is completed (either by result or cancellation), dispose the resources.
        tcs.Task.ContinueWith(_ =>
        {
            registration.Dispose();
            cts.Dispose();
        }, TaskScheduler.Default);

        return tcs.Task;
    }



    public virtual async Task HandlePeerDownAsync(string nodeId)
    {
        try
        {
            var node = _peerManager.GetAllKnownPeers().FirstOrDefault(n => n.NodeId == nodeId);
            if (node == null)
            {
                _logger.LogWarning("HandlePeerDownAsync called, but node {NodeId} not found in registry.", nodeId);
                return;
            }

            // Vet and remove via central peer manager
            bool removed = await _peerManager.TryRemovePeerAsync(node, async p =>
            {
                bool reachable = await CanReachNodeAsync(p);
                _logger.LogDebug("Vet before removal: node {NodeId} reachable? {Reachable}", p.NodeId, reachable);
                return !reachable;
            });
        }
        finally
        {
            RemoveConnection(nodeId);
        }
    }

    protected static async Task ReadExactlyAsync(Stream stream, byte[] buffer, int offset, int count)
    {
        int readTotal = 0;
        while (readTotal < count)
        {
            int read = await stream.ReadAsync(buffer, offset + readTotal, count - readTotal);
            if (read == 0)
                throw new EndOfStreamException($"Expected {count} bytes but got {readTotal}");
            readTotal += read;
        }
    }

    private async Task SendSafeAsync(NodeInfo peer, byte[] data)
    {
        try
        {
            await SendAsync(peer, data);
        }
        catch (Exception ex)
        {
            _logger.LogWarning("Failed to send broadcast to {NodeId}: {Message}", peer.NodeId, ex.Message);
        }
    }

    private void CleanupIdleConnections(TimeSpan idleTimeout)
    {
        foreach (var conn in _connections)
        {
            if (DateTime.UtcNow - conn.Value.LastUsedUtc > idleTimeout)
            {
                _logger.LogWarning(
                "Disposing idle connection to {RemoteNodeId} (idle for {IdleDuration} seconds)",
                conn.Value.RemoteNodeId, (int)idleTimeout.TotalSeconds);

                HandlePeerDownAsync(conn.Value.RemoteNodeId);
            }
        }
    }

    public abstract Task SendImmediateAsync(NodeInfo target, Message message);
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Transport\DuplexTcpTransport.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Configuration;
using Clustron.Core.Discovery;
using Clustron.Core.Helpers;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Observability;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;
using System.Buffers;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.IO.Pipelines;
using System.Net;
using System.Net.Sockets;

namespace Clustron.Core.Transport;

public class DuplexTcpTransport : BaseTcpTransport
{
    private readonly int _port;
    private readonly IDiscoveryProvider _discoveryProvider;
    private readonly RetryOptions _retryOptions;
    private readonly ClusterPeerManager _peerManager;
    private TcpListener? _listener;
    private readonly IMetricContributor _metrics;


    public DuplexTcpTransport(
        int port,
        IClusterRuntime clusterRuntime,
        IMessageSerializer serializer,
        IMetricContributor metrics,
        IClusterLoggerProvider loggerProvider,
        RetryOptions retryOptions)
        : base(clusterRuntime, serializer, loggerProvider.GetLogger<DuplexTcpTransport>())
    {
        _port = port;
        _peerManager = clusterRuntime.PeerManager;
        _metrics = metrics;
        _retryOptions = retryOptions;
    }

    public override Task StartAsync(IMessageRouter router)
    {
        _logger.LogInformation("TCP listener starting on port {Port}", _port);

        _listener = new TcpListener(IPAddress.Any, _port);
        _listener.Start();

        _ = Task.Run(async () =>
        {
            _logger.LogInformation("TCP listener started on port {Port}", _port);

            while (true)
            {
                try
                {
                    var client = await _listener.AcceptTcpClientAsync();
                    _ = HandleClientAsync(client, router);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error in TCP listener loop");
                }
            }
        });

        return Task.CompletedTask;
    }


    //private async Task HandleClientAsync(TcpClient client, IMessageRouter router)
    //{
    //    using var stream = client.GetStream();
    //    string? senderId = null;

    //    try
    //    {
    //        while (true)
    //        {
    //            var lengthBuffer = ArrayPool<byte>.Shared.Rent(4);
    //            try
    //            {
    //                await ReadExactlyAsync(stream, lengthBuffer, 0, 4);

    //                int length = BitConverter.ToInt32(lengthBuffer, 0);
    //                if (length <= 0 || length > 1024 * 10)
    //                {
    //                    _logger.LogCritical("HandleClientAsync: Invalid message length received: {Length}", length);
    //                    break;
    //                }

    //                var payloadBuffer = ArrayPool<byte>.Shared.Rent(length);
    //                try
    //                {
    //                    await ReadExactlyAsync(stream, payloadBuffer, 0, length);
    //                    var message = _serializer.Deserialize<Message>(payloadBuffer.AsSpan(0, length));

    //                    if (message == null) continue;

    //                    senderId = message.SenderId;

    //                    if (!string.IsNullOrEmpty(message.CorrelationId) &&
    //                        _responseAwaiters.TryGetValue(message.CorrelationId, out var tcs))
    //                    {
    //                        tcs.TrySetResult(message);
    //                        _responseAwaiters.TryRemove(message.CorrelationId, out _);
    //                    }
    //                    else
    //                    {
    //                        if(message.MessageType == MessageTypes.NodeLeft)
    //                            _logger.LogCritical("Something unexpected happened. CorrelationId: {CorrelationId} for message {message}", message.CorrelationId, message.ToString());
    //                        await router.RouteAsync(message);
    //                    }
    //                }
    //                finally
    //                {
    //                    ArrayPool<byte>.Shared.Return(payloadBuffer);
    //                }
    //            }
    //            finally
    //            {
    //                ArrayPool<byte>.Shared.Return(lengthBuffer);
    //            }
    //        }
    //    }
    //    catch (Exception ex)
    //    {
    //        _logger.LogCritical("Inbound connection failed: {Error}", ex.ToString());
    //    }
    //    finally
    //    {
    //        if (!string.IsNullOrEmpty(senderId))
    //        {
    //            await HandlePeerDownAsync(senderId); // triggers proper peer removal
    //        }

    //        client.Close();
    //    }
    //}

    private async Task HandleClientAsync(TcpClient client, IMessageRouter router)
    {
        using var stream = client.GetStream();
        var reader = PipeReader.Create(stream);
        string? senderId = null;

        try
        {
            while (true)
            {
                var result = await reader.ReadAsync();
                var buffer = result.Buffer;

                while (TryReadMessage(ref buffer, out var message))
                {
                    senderId = message.SenderId;

                    if (!string.IsNullOrEmpty(message.CorrelationId) &&
                        _responseAwaiters.TryRemove(message.CorrelationId, out var tcs))
                    {
                        tcs.TrySetResult(message);
                    }
                    else
                    {
                        await router.RouteAsync(message);
                        _metrics.Increment(MetricKeys.Msg.Wire.Received);
                    }
                }

                reader.AdvanceTo(buffer.Start, buffer.End);

                if (result.IsCompleted)
                    break;
            }
        }
        catch (Exception ex)
        {
            _logger.LogCritical("Inbound connection failed: {Error}", ex.ToString());
        }
        finally
        {
            if (!string.IsNullOrEmpty(senderId))
                await HandlePeerDownAsync(senderId);

            client.Close();
        }
    }

    
    public override async Task SendAsync(NodeInfo target, Message message)
    {
        var body = _serializer.Serialize(message);
        await SendAsync(target, body);

    }

    public override async Task SendAsync(NodeInfo target, byte[] data)
    {
        var length = BitConverter.GetBytes(data.Length);

        var sendLock = _sendLocks.GetOrAdd(target.NodeId, _ => new SemaphoreSlim(1, 1));
        await sendLock.WaitAsync();

        try
        {
            await RetryHelper.RetryAsync(async () =>
            {
                var conn = await GetOrCreateConnectionAsync(target);
                if (conn?.IsConnected != true)
                    throw new IOException("Connection not available");

                conn.LastUsedUtc = DateTime.UtcNow;
                var stream = conn.Stream;

                //  Use a single buffer to reduce syscalls
                var buffer = ArrayPool<byte>.Shared.Rent(length.Length + data.Length);
                try
                {
                    Buffer.BlockCopy(length, 0, buffer, 0, length.Length);
                    Buffer.BlockCopy(data, 0, buffer, length.Length, data.Length);

                    await stream.WriteAsync(buffer.AsMemory(0, length.Length + data.Length));
                }
                finally
                {
                    ArrayPool<byte>.Shared.Return(buffer);
                }
            }, _retryOptions.MaxAttempts, _retryOptions.DelayMilliseconds, _logger);

            _metrics.Increment(MetricKeys.Msg.Wire.Sent);
        }
        catch (Exception ex)
        {
            _logger.LogWarning("Failed to send message to {NodeId}: {Message}", target.NodeId, ex.Message);
            _connections.TryRemove(target.NodeId, out var failedConn);
            failedConn?.Dispose();
        }
        finally
        {
            sendLock.Release();
        }
    }

    private bool TryReadMessage(ref ReadOnlySequence<byte> buffer, out Message? message)
    {
        message = null;

        var reader = new SequenceReader<byte>(buffer);
        if (!reader.TryReadLittleEndian(out int length))
            return false;

        if (reader.Remaining < length)
            return false;

        var payload = buffer.Slice(reader.Position, length);

        try
        {
            message = _serializer.Deserialize<Message>(payload.ToArray()); // Optimize: use Span-based overload if available
        }
        catch
        {
            return false;
        }

        buffer = buffer.Slice(reader.Position).Slice(length);
        return true;
    }

    private async Task<PersistentConnection?> GetOrCreateConnectionAsync(NodeInfo target)
    {
        if (_connections.TryGetValue(target.NodeId, out var existingConn) && existingConn.IsConnected)
        {
            existingConn.LastUsedUtc = DateTime.UtcNow;
            return existingConn;
        }

        try
        {
            _logger.LogDebug("Connecting to {NodeId} at {Host}:{Port}", target.NodeId, target.Host, target.Port);
            var client = new TcpClient();
            await client.ConnectAsync(target.Host, target.Port);

            var persistent = new PersistentConnection(client)
            {
                RemoteNodeId = target.NodeId,
                IsInbound = false
            };

            _connections[target.NodeId] = persistent;

            _logger.LogInformation("Outbound connection to {NodeId} established", target.NodeId);
            return persistent;
        }
        catch (Exception ex)
        {
            _logger.LogWarning("Failed to connect to {NodeId}: {Error}", target.NodeId, ex.Message);
            return null;
        }
    }

    public override async Task<bool> CanReachNodeAsync(NodeInfo node)
    {
        try
        {
            var conn = await GetOrCreateConnectionAsync(node);
            if (conn?.IsConnected == true)
            {
                conn.LastUsedUtc = DateTime.UtcNow;
                return true;
            }
        }
        catch
        {
        }

        return false;
    }

    public override Task SendImmediateAsync(NodeInfo target, Message message) => SendAsync(target, message);

    public override void RemoveConnection(string nodeId)
    {
        if (_connections.TryRemove(nodeId, out var conn))
        {
            conn.Dispose();
            _logger.LogInformation("Removed connection to {NodeId}", nodeId);
        }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Transport\ITransport.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Messaging;
using Clustron.Core.Models;

namespace Clustron.Core.Transport
{
    public interface ITransport
    {
        Task SendAsync(NodeInfo target, Message message);
        Task StartAsync(IMessageRouter router);          
        Task<Message> WaitForResponseAsync(string expectedSenderId, string correlationId, TimeSpan timeout);
        Task BroadcastAsync(Message message, params string[] roles);
        void RemoveConnection(string nodeId);
        Task<bool> CanReachNodeAsync(NodeInfo node);
        Task HandlePeerDownAsync(string nodeId);

        Task SendImmediateAsync(NodeInfo target, Message message);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Transport\ITransportFactory.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Transport;

public interface ITransportFactory
{
    ITransport Create();
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Transport\NullTransport.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Transport;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Clustron.Core.Transport;
public class NullTransport : ITransport
{
    public Task SendAsync(NodeInfo target, Message message)
    {
        return Task.CompletedTask;
    }

    public Task StartAsync(IMessageRouter router)
    {
        return Task.CompletedTask;
    }

    public Task<Message> WaitForResponseAsync(string expectedSenderId, string correlationID, TimeSpan timeout)
    {
        return Task.FromResult<Message>(null!); // Will crash if called  placeholder only
    }

    public Task BroadcastAsync(Message message, params string[] roles)
    {
        return Task.CompletedTask;
    }

    public void RemoveConnection(string nodeId)
    {
        throw new NotImplementedException();
    }

    public Task<bool> CanReachNodeAsync(NodeInfo node)
    {
        throw new NotImplementedException();
    }

    public Task HandlePeerDownAsync(string nodeId)
    {
        throw new NotImplementedException();
    }

    public Task SendImmediateAsync(NodeInfo target, Message message)
    {
        throw new NotImplementedException();
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Transport\PersistentConnection.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System.Net.Sockets;

namespace Clustron.Core.Transport;
public class PersistentConnection
{
    public TcpClient Client { get; }
    public NetworkStream Stream => Client.GetStream();
    public DateTime LastUsedUtc { get; set; }
    public string? RemoteNodeId { get; set; }
    public bool IsInbound { get; set; }

    public PersistentConnection(TcpClient client)
    {
        Client = client;
        LastUsedUtc = DateTime.UtcNow;
    }

    public bool IsConnected =>
        Client.Connected && !(Client.Client.Poll(1, SelectMode.SelectRead) && Client.Available == 0);

    public void Dispose()
    {
        try
        {
            Client.Close();
            Client.Dispose();
        }
        catch { }
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Transport\PipelinedTcpTransport.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Configuration;
using Clustron.Core.Helpers;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Observability;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;
using System.Buffers;
using System.Collections.Concurrent;
using System.IO.Pipelines;
using System.Net;
using System.Net.Sockets;
using System.Threading.Channels;

namespace Clustron.Core.Transport;

public class PipelinedTcpTransport : BaseTcpTransport
{
    private readonly int _port;
    private TcpListener? _listener;
    private readonly ConcurrentDictionary<string, Channel<byte[]>> _outgoingChannels = new();
    private readonly ConcurrentDictionary<string, SemaphoreSlim> _teardownLocks = new();

    private readonly IMetricContributor _metrics;
    private readonly RetryOptions _retryOptions;

    public PipelinedTcpTransport(
        int port,
        IClusterRuntime runtime,
        IMessageSerializer serializer,
        IMetricContributor metrics,
        IClusterLoggerProvider loggerProvider,
        RetryOptions retryOptions)
        : base(runtime, serializer, loggerProvider.GetLogger<PipelinedTcpTransport>())
    {
        _port = port;
        _metrics = metrics;
        _retryOptions = retryOptions;
    }

    public override Task StartAsync(IMessageRouter router)
    {
        _listener = new TcpListener(IPAddress.Any, _port);
        _listener.Start();

        _ = Task.Run(async () =>
        {
            while (true)
            {
                var client = await _listener.AcceptTcpClientAsync();
                _ = HandleClientAsync(client, router);
            }
        });

        return Task.CompletedTask;
    }

    private async Task HandleClientAsync(TcpClient client, IMessageRouter router)
    {
        using var stream = client.GetStream();
        var reader = PipeReader.Create(stream);
        string? senderId = null;

        try
        {
            while (true)
            {
                var result = await reader.ReadAsync();
                var buffer = result.Buffer;

                while (TryReadMessage(ref buffer, out var message))
                {
                    senderId = message.SenderId;

                    if (!string.IsNullOrEmpty(message.CorrelationId) &&
                        _responseAwaiters.TryRemove(message.CorrelationId, out var tcs))
                    {
                        tcs.TrySetResult(message);
                    }
                    else
                    {
                        await router.RouteAsync(message);
                        _metrics.Increment(MetricKeys.Msg.Wire.Received);
                    }
                }

                reader.AdvanceTo(buffer.Start, buffer.End);

                if (result.IsCompleted)
                {
                    if (!string.IsNullOrEmpty(senderId))
                    {
                        _logger.LogInformation("Client {SenderId} disconnected gracefully", senderId);
                        await HandlePeerDownAsync(senderId); 
                    }
                    break;
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError("HandleClientAsync failed: {Error}", ex.Message);
        }
        finally
        {
            if (!string.IsNullOrEmpty(senderId))
                await HandlePeerDownAsync(senderId);

            client.Close();
        }
    }

    public virtual async Task HandlePeerDownAsync(string nodeId)
    {
        var teardownLock = _teardownLocks.GetOrAdd(nodeId, _ => new SemaphoreSlim(1, 1));
        await teardownLock.WaitAsync();

        try
        {
            var node = _peerManager.GetAllKnownPeers().FirstOrDefault(n => n.NodeId == nodeId);
            if (node == null)
            {
                _logger.LogWarning("HandlePeerDownAsync called, but node {NodeId} not found in registry.", nodeId);
                return;
            }

            // Vet and remove via central peer manager
            bool removed = await _peerManager.TryRemovePeerAsync(node, async p =>
            {
                bool reachable = await CanReachNodeAsync(p);
                _logger.LogDebug("Vet before removal: node {NodeId} reachable? {Reachable}", p.NodeId, reachable);
                return !reachable;
            });

            if(removed)
                RemoveConnection(nodeId);
        }
        finally
        {
            
            _teardownLocks.TryRemove(nodeId, out _); 
            teardownLock.Release();
        }
    }

    private bool TryReadMessage(ref ReadOnlySequence<byte> buffer, out Message? message)
    {
        message = null;
        var reader = new SequenceReader<byte>(buffer);

        if (!reader.TryReadLittleEndian(out int length) || reader.Remaining < length)
            return false;

        var payload = buffer.Slice(reader.Position, length);
        message = _serializer.Deserialize<Message>(payload.ToArray());

        buffer = buffer.Slice(reader.Position).Slice(length);
        return true;
    }

    public override async Task SendAsync(NodeInfo target, Message message)
    {
        var data = _serializer.Serialize(message);
        await SendAsync(target, data);
    }

    public override async Task SendAsync(NodeInfo target, byte[] data)
    {
        var channel = GetOrCreateValidChannel(target);

        if (!channel.Writer.TryWrite(data))
        {
            try
            {
                await channel.Writer.WriteAsync(data);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "WriteAsync failed to {NodeId}", target.NodeId);
                _outgoingChannels.TryRemove(target.NodeId, out _);
            }
        }
    }

    private Channel<byte[]> GetOrCreateValidChannel(NodeInfo target)
    {
        
        while (true)
        {
            if (_outgoingChannels.TryGetValue(target.NodeId, out var existing))
            {
                if (!existing.Reader.Completion.IsCompleted)
                    return existing;

                _outgoingChannels.TryRemove(target.NodeId, out _);
            }

            var newChannel = CreateChannel(target);
            if (_outgoingChannels.TryAdd(target.NodeId, newChannel))
                return newChannel;
        }
    }

    private Channel<byte[]> CreateChannel(NodeInfo target)
    {
        _logger.LogCritical("Creating new channel for {NodeId}", target.NodeId);

        if (!_peerManager.IsAlive(target.NodeId))
        {
            _logger.LogWarning("Refusing to create channel for dead node {NodeId}", target.NodeId);
            throw new IOException($"Node {target.NodeId} is marked down");
        }

        var ch = Channel.CreateUnbounded<byte[]>();
        _ = Task.Run(() => ProcessSendQueue(target, ch.Reader));
        return ch;
    }

    private async Task ProcessSendQueue(NodeInfo target, ChannelReader<byte[]> reader)
    {
        PersistentConnection? conn = null;
        var lockObj = _sendLocks.GetOrAdd(target.NodeId, _ => new SemaphoreSlim(1, 1));

        while (await reader.WaitToReadAsync())
        {
            while (reader.TryRead(out var data))
            {
                await lockObj.WaitAsync();

                try
                {
                    await RetryHelper.RetryAsync(async () =>
                    {
                        conn ??= await GetOrCreateConnectionAsync(target);
                        if (conn?.IsConnected != true)
                        {
                            conn?.Dispose();
                            _connections.TryRemove(target.NodeId, out _);
                            conn = await GetOrCreateConnectionAsync(target);
                        }

                        if (conn == null || !conn.IsConnected)
                            throw new IOException("No available connection");

                        var stream = conn.Stream;
                        var buffer = ArrayPool<byte>.Shared.Rent(4 + data.Length);
                        try
                        {
                            BitConverter.TryWriteBytes(buffer.AsSpan(0, 4), data.Length);
                            Buffer.BlockCopy(data, 0, buffer, 4, data.Length);
                            await stream.WriteAsync(buffer.AsMemory(0, 4 + data.Length));
                            conn.LastUsedUtc = DateTime.UtcNow;
                        }
                        finally
                        {
                            ArrayPool<byte>.Shared.Return(buffer);
                        }
                    }, _retryOptions.MaxAttempts, _retryOptions.DelayMilliseconds, _logger);

                    _metrics.Increment(MetricKeys.Msg.Wire.Sent);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning("Send failed to {NodeId}: {Message}", target.NodeId, ex.Message);

                    conn?.Dispose();
                    _connections.TryRemove(target.NodeId, out _);
                    conn = null;

                    await HandlePeerDownAsync(target.NodeId);

                    // Mark the channel complete to exit the send loop
                    if (_outgoingChannels.TryRemove(target.NodeId, out var channel))
                    {
                        channel.Writer.TryComplete();
                    }

                    return; // Break out of loop  no point retrying further
                }

                finally
                {
                    lockObj.Release();
                }
            }
        }
    }

    private async Task<PersistentConnection?> GetOrCreateConnectionAsync(NodeInfo target)
    {
        if (_teardownLocks.TryGetValue(target.NodeId, out var teardownLock))
            await teardownLock.WaitAsync(); // Wait until the node is fully processed
        try
        {
            if (_connections.TryGetValue(target.NodeId, out var existingConn) && existingConn.IsConnected)
            {
                existingConn.LastUsedUtc = DateTime.UtcNow;
                return existingConn;
            }

            try
            {
                var client = new TcpClient();
                await client.ConnectAsync(target.Host, target.Port);
                var conn = new PersistentConnection(client)
                {
                    RemoteNodeId = target.NodeId,
                    IsInbound = false
                };
                _connections[target.NodeId] = conn;
                return conn;
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Failed to connect to {NodeId}: {Error}", target.NodeId, ex.Message);
                return null;
            }
        }
        finally
        {
            teardownLock?.Release();
        }
    }

    public async override Task SendImmediateAsync(NodeInfo target, Message message)
    {
        var data = _serializer.Serialize(message);
        var lockObj = _sendLocks.GetOrAdd(target.NodeId, _ => new SemaphoreSlim(1, 1));
        await lockObj.WaitAsync();

        try
        {
            var conn = await GetOrCreateConnectionAsync(target);
            if (conn?.IsConnected != true)
                throw new IOException("Connection unavailable");

            var stream = conn.Stream;
            var buffer = ArrayPool<byte>.Shared.Rent(4 + data.Length);
            try
            {
                BitConverter.TryWriteBytes(buffer.AsSpan(0, 4), data.Length);
                Buffer.BlockCopy(data, 0, buffer, 4, data.Length);

                await stream.WriteAsync(buffer.AsMemory(0, 4 + data.Length));
                conn.LastUsedUtc = DateTime.UtcNow;
            }
            finally
            {
                ArrayPool<byte>.Shared.Return(buffer);
            }

            _metrics.Increment(MetricKeys.Msg.Wire.Sent);
        }
        catch (Exception ex)
        {
            _logger.LogWarning("Immediate send failed to {NodeId}: {Message}", target.NodeId, ex.Message);
            _connections.TryRemove(target.NodeId, out var failedConn);
            failedConn?.Dispose();
            throw;
        }
        finally
        {
            lockObj.Release();
        }
    }


    public override Task<bool> CanReachNodeAsync(NodeInfo node)
    {
        return Task.FromResult(_connections.TryGetValue(node.NodeId, out var conn) && conn.IsConnected);
    }

    public override void RemoveConnection(string nodeId)
    {
        if (_connections.TryRemove(nodeId, out var conn))
        {
            conn.Dispose();
            _logger.LogInformation("Removed connection to {NodeId}", nodeId);
        }

        if (_outgoingChannels.TryRemove(nodeId, out var channel))
        {
            channel.Writer.TryComplete(); // Signal send loop to exit
            _logger.LogInformation("Closed send channel for {NodeId}", nodeId);
        }
        _sendLocks.TryRemove(nodeId, out _);
    }
}


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Transport\TransportFactory.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Configuration;
using Clustron.Core.Discovery;
using Clustron.Core.Observability;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Options;

namespace Clustron.Core.Transport;

public class TransportFactory : ITransportFactory
{
    private readonly ClustronConfig _config;
    private readonly IClusterRuntime _clusterRuntime;
    private readonly IMessageSerializer _serializer;
    private readonly IDiscoveryProvider _discovery;
    private readonly IClusterLoggerProvider _loggerProvider;
    private readonly IClusterCommunication _communication;
    private readonly IMetricContributor _metricContributor;

    public TransportFactory(
        IOptions<ClustronConfig> config,
        IClusterRuntime clusterRuntime,
        IClusterCommunication communication,
        IMessageSerializer serializer,
        IDiscoveryProvider discovery,
        IMetricContributor metrics,
        IClusterLoggerProvider loggerProvider)
    {
        _config = config.Value;
        _clusterRuntime = clusterRuntime;
        _serializer = serializer;
        _discovery = discovery;
        _communication = communication;
        _loggerProvider = loggerProvider;
        _metricContributor = metrics;
    }

    public ITransport Create()
    {
        ITransport transport = _config.UseDuplexConnections
            ? new PipelinedTcpTransport(_config.Port, _clusterRuntime, _serializer, _metricContributor, _loggerProvider, _config.RetryOptions)
            : new UnidirectionalTcpTransport(_config.Port, _clusterRuntime, _serializer, _loggerProvider);

        _communication.OverrideTransport(transport); // important for ClusterContext transport access
        return transport;
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Transport\UnidirectionalTcpTransport.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Discovery;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;
using System.Buffers;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;

namespace Clustron.Core.Transport;

public class UnidirectionalTcpTransport : BaseTcpTransport
{
    private readonly int _port;
    private readonly ClusterPeerManager _peerManager;
    private readonly IDiscoveryProvider _discoveryProvider;

    public UnidirectionalTcpTransport(
        int port,
        IClusterRuntime clusterRuntime,
        IMessageSerializer serializer,
        IClusterLoggerProvider loggerProvider)
        : base(clusterRuntime, serializer, loggerProvider.GetLogger<UnidirectionalTcpTransport>())
    {
        _port = port;
        _peerManager = clusterRuntime.PeerManager;
    }

    public override Task StartAsync(IMessageRouter router)
    {
        var listener = new TcpListener(IPAddress.Any, _port);
        listener.Start();

        _ = Task.Run(async () =>
        {
            while (true)
            {
                var client = await listener.AcceptTcpClientAsync();
                _ = HandleClientAsync(client, router);
            }
        });

        return Task.CompletedTask;
    }

    private async Task HandleClientAsync(TcpClient client, IMessageRouter router)
    {
        using var stream = client.GetStream();
        string? senderId = null;

        try
        {
            while (true)
            {
                var lengthBuffer = ArrayPool<byte>.Shared.Rent(4);
                try
                {
                    int read = await stream.ReadAsync(lengthBuffer, 0, 4);
                    if (read == 0) break;

                    int length = BitConverter.ToInt32(lengthBuffer, 0);
                    if (length <= 0 || length > 1024 * 10) break;

                    var payloadBuffer = ArrayPool<byte>.Shared.Rent(length);
                    try
                    {
                        await ReadExactlyAsync(stream, payloadBuffer, 0, length);
                        var payload = payloadBuffer.AsSpan(0, length).ToArray();
                        var message = _serializer.Deserialize<Message>(payload);

                        if (message == null) continue;

                        senderId = message.SenderId;

                        if (!_peerManager.IsAlive(senderId))
                        {
                            var remoteEndpoint = (IPEndPoint?)client.Client.RemoteEndPoint;
                            if (remoteEndpoint != null)
                            {
                                var nodeInfo = new NodeInfo
                                {
                                    NodeId = senderId,
                                    Host = remoteEndpoint.Address.ToString(),
                                    Port = remoteEndpoint.Port
                                };

                                _peerManager.RegisterPeer(nodeInfo);
                                _logger.LogInformation("Registered new inbound peer: {SenderId}", senderId);
                            }
                        }

                        if (!string.IsNullOrEmpty(message.CorrelationId) &&
                            _responseAwaiters.TryGetValue(message.CorrelationId, out var tcs))
                        {
                            tcs.TrySetResult(message);
                            _responseAwaiters.TryRemove(message.CorrelationId, out _);
                        }
                        else
                        {
                            await router.RouteAsync(message);
                        }
                    }
                    finally
                    {
                        ArrayPool<byte>.Shared.Return(payloadBuffer);
                    }
                }
                finally
                {
                    ArrayPool<byte>.Shared.Return(lengthBuffer);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning("Inbound connection failed: {Error}", ex.Message);
        }
        finally
        {
            if (!string.IsNullOrEmpty(senderId))
            {
                await HandlePeerDownAsync(senderId); 
            }
            client.Close();
        }
    }

    public override async Task HandlePeerDownAsync(string nodeId)
    {
        var node = _peerManager.GetAllKnownPeers().FirstOrDefault(n => n.NodeId == nodeId);
        if (node == null)
        {
            _logger.LogWarning("HandlePeerDownAsync: node {NodeId} not found in known peers.", nodeId);
            return;
        }

        // Run vetting logic via centralized manager
        bool removed = await _peerManager.TryRemovePeerAsync(node, async p =>
        {
            bool reachable = await CanReachNodeAsync(p);
            _logger.LogDebug("Peer {NodeId} reachable? {Reachable}", p.NodeId, reachable);
            return !reachable;
        });

        if (removed)
        {
            RemoveConnection(nodeId);
        }
    }


    public override async Task SendAsync(NodeInfo target, Message message)
    {
        var body = _serializer.Serialize(message);
        var length = BitConverter.GetBytes(body.Length);

        var sendLock = _sendLocks.GetOrAdd(target.NodeId, _ => new SemaphoreSlim(1, 1));
        await sendLock.WaitAsync();
        try
        {
            var conn = await GetOrCreateConnectionAsync(target);
            if (conn?.IsConnected != true)
            {
                _logger.LogWarning("Connection to {NodeId} unavailable.", target.NodeId);
                return;
            }

            conn.LastUsedUtc = DateTime.UtcNow;
            var stream = conn.Stream;

            await stream.WriteAsync(length, 0, length.Length);
            await stream.WriteAsync(body, 0, body.Length);
        }
        catch (Exception ex)
        {
            _logger.LogWarning("Failed to send message to {NodeId}: {Message}", target.NodeId, ex.Message);
            _connections.TryRemove(target.NodeId, out var failedConn);
            failedConn?.Dispose();
        }
        finally
        {
            sendLock.Release();
        }
    }

    private async Task<PersistentConnection?> GetOrCreateConnectionAsync(NodeInfo target)
    {
        if (_connections.TryGetValue(target.NodeId, out var existingConn) && existingConn.IsConnected)
        {
            existingConn.LastUsedUtc = DateTime.UtcNow;
            return existingConn;
        }

        try
        {
            _logger.LogDebug("Connecting to {NodeId} at {Host}:{Port}", target.NodeId, target.Host, target.Port);
            var client = new TcpClient();
            await client.ConnectAsync(target.Host, target.Port);

            var persistent = new PersistentConnection(client)
            {
                RemoteNodeId = target.NodeId,
                IsInbound = false
            };

            _connections[target.NodeId] = persistent;

            _logger.LogInformation("Successfully connected to {NodeId}", target.NodeId);

            return persistent;
        }
        catch (Exception ex)
        {
            _logger.LogWarning("Failed to connect to {NodeId}: {Error}", target.NodeId, ex.Message);
            return null; 
        }
    }

    public override async Task<bool> CanReachNodeAsync(NodeInfo node)
    {
        try
        {
            var conn = await GetOrCreateConnectionAsync(node);
            return conn?.IsConnected == true;
        }
        catch
        {
            return false;
        }
    }

    public override void RemoveConnection(string nodeId)
    {
        if (_connections.TryRemove(nodeId, out var conn))
        {
            conn.Dispose();
            _logger.LogInformation("Removed outbound connection to {NodeId}", nodeId);
        }
    }

    public override Task SendAsync(NodeInfo target, byte[] data)
    {
        throw new NotImplementedException();
    }

    public override Task SendImmediateAsync(NodeInfo target, Message message)
    {
        throw new NotImplementedException();
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\Behaviors\ClusterViewBroadcasterBehavior.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster;
using Clustron.Core.Configuration;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Clustron.Core.Transport;
using Microsoft.Extensions.Logging;
using System.Timers;

namespace Clustron.Core.Cluster.Behaviors;

public class ClusterViewBroadcasterBehavior : IRoleAwareBehavior
{
    private readonly ILogger<ClusterViewBroadcasterBehavior> _logger;
    private readonly ClusterPeerManager _peerManager;
    private readonly IMessageSerializer _serializer;
    private readonly NodeInfo _self;
    private readonly IClusterCommunication _communication;
    private System.Timers.Timer? _timer;

    private static readonly TimeSpan BroadcastInterval = TimeSpan.FromMinutes(10);

    public string Name => "ClusterViewBroadcaster";

    public ClusterViewBroadcasterBehavior(
        ILogger<ClusterViewBroadcasterBehavior> logger,
        IClusterRuntime runtime,
        IMessageSerializer serializer,
        IClusterCommunication communication)
    {
        _logger = logger;
        _peerManager = runtime.PeerManager;
        _serializer = serializer;
        _self = runtime.Self;
        _communication = communication;
    }

    public Task StartAsync()
    {
        _timer = new System.Timers.Timer(BroadcastInterval.TotalMilliseconds);
        _timer.Elapsed += async (_, _) => await BroadcastClusterViewAsync();
        _timer.AutoReset = true;
        _timer.Start();

        _logger.LogInformation("ClusterViewBroadcaster started.");
        return Task.CompletedTask;
    }

    private async Task BroadcastClusterViewAsync()
    {
        var peers = _peerManager.GetActivePeers().Where(p => p.NodeId != _self.NodeId).ToList();

        if (!peers.Any())
            return;

        var view = new ClusterViewPayload
        {
            KnownPeers = peers
        };

        var message = MessageBuilder.Create<ClusterViewPayload>(_self.NodeId, MessageTypes.ClusterView, Guid.NewGuid().ToString(), view);

        foreach (var peer in peers)
        {
            try
            {
                await _communication.Transport.SendAsync(peer, message);
            }
            catch (Exception ex)
            {
                _logger.LogWarning("Failed to send cluster view to {NodeId}: {Error}", peer.NodeId, ex.Message);
            }
        }

        _logger.LogDebug("Broadcasted cluster view to {Count} peers", peers.Count);
    }

    public bool ShouldRunInRole(IList<string> roles)
            => roles.Contains(ClustronRoles.Member);
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\Behaviors\ElectionBehavior.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Configuration;
using Clustron.Core.Election;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster.Behaviors
{
    public class ElectionBehavior : IRoleAwareBehavior
    {
        private readonly ElectionCoordinator _coordinator;
        private readonly ILogger<ElectionBehavior> _logger;
        private readonly ClusterPeerManager _peerManager;

        public string Name => "Election";

        public ElectionBehavior(
            ElectionCoordinator coordinator,
            ClusterPeerManager peerManager,
            ILogger<ElectionBehavior> logger)
        {
            _coordinator = coordinator;
            _peerManager = peerManager;
            _logger = logger;
        }

        public Task StartAsync()
        {
            // Optional: leave empty or trigger election on startup from ElectionCoordinatorBehavior
            return Task.CompletedTask;
        }

        public async Task<NodeInfo?> RunElectionAsync()
        {
            var leader = await _coordinator.ElectLeaderAsync(_peerManager.GetActivePeers());

            if (leader != null)
            {
                _logger.LogInformation("Elected leader: {NodeId}", leader.NodeId);
            }
            else
            {
                _logger.LogWarning("No eligible leader could be elected.");
            }

            return leader;
        }

        public bool ShouldRunInRole(IList<string> roles)
            => roles.Contains(ClustronRoles.Member);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\Behaviors\ElectionCoordinatorBehavior.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Cluster.Behaviors;
using Clustron.Core.Configuration;
using Clustron.Core.Election;
using Clustron.Core.Events;
using Clustron.Core.Health;
using Clustron.Core.Lifecycle;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;

public class ElectionCoordinatorBehavior : IRoleAwareBehavior
{
    private readonly IHeartbeatMonitor _heartbeat;
    private readonly ILeaderElectionService _electionService;
    private readonly ILogger<ElectionCoordinatorBehavior> _logger;
    private readonly IClusterEventBus _eventBus;


    public string Name => "ElectionCoordinator";

    public ElectionCoordinatorBehavior(
        IHeartbeatMonitor heartbeat,
        ILeaderElectionService electionService,
        IClusterEventBus eventBus,
        ILogger<ElectionCoordinatorBehavior> logger)
    {
        _heartbeat = heartbeat;
        _electionService = electionService;
        _eventBus = eventBus;
        _logger = logger;
    }

    public Task StartAsync()
    {
        _heartbeat.OnNodeFailed += async failed =>
        {
            _logger.LogWarning("OnNodeFailed received: {NodeId}, CurrentLeader: {LeaderId}",
                failed.NodeId, _electionService.CurrentLeader?.NodeId);
            if (_electionService.CurrentLeader?.NodeId == failed.NodeId)
            {
                _logger.LogWarning("Leader failed: {NodeId}. Triggering re-election.", failed.NodeId);
                await _electionService.TryHoldElectionAsync();
            }
        };

        _eventBus.Subscribe<NodeLeftEvent>(e =>
        {
            if (_electionService.CurrentLeader?.NodeId == e.Node.NodeId)
            {
                _logger.LogWarning("Leader left via NodeLeftEvent: {NodeId}. Triggering re-election.", e.Node.NodeId);
                _ = _electionService.TryHoldElectionAsync();
            }
        });

        if (_electionService.CurrentLeader == null)
            _ = _electionService.TryHoldElectionAsync();

        return Task.CompletedTask;
    }

    public Task OnNodeJoinedAsync(NodeInfo node) => Task.CompletedTask;

    public Task OnNodeLeftAsync(NodeInfo node)
    {
        if (_electionService.CurrentLeader?.NodeId == node.NodeId)
        {
            _logger.LogWarning("Leader left: {NodeId}. Triggering re-election.", node.NodeId);
            return _electionService.TryHoldElectionAsync();
        }
        return Task.CompletedTask;
    }

    public bool ShouldRunInRole(IList<string> roles)
            => roles.Contains(ClustronRoles.Member);
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\Behaviors\HeartbeatMonitorBehavior.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Configuration;
using Clustron.Core.Health;
using Clustron.Core.Models;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster.Behaviors
{
    public class HeartbeatMonitorBehavior : IRoleAwareBehavior
    {
        private readonly IHeartbeatMonitor _heartbeat;
        private readonly NodeInfo _self;
        private readonly ClusterPeerManager _peerManager;
        private readonly ILogger<HeartbeatMonitorBehavior> _logger;

        public string Name => "HeartbeatMonitor";

        public HeartbeatMonitorBehavior(
            IHeartbeatMonitor heartbeat,
            NodeInfo self,
            ClusterPeerManager peerManager,
            ILogger<HeartbeatMonitorBehavior> logger)
        {
            _heartbeat = heartbeat;
            _self = self;
            _peerManager = peerManager;
            _logger = logger;
        }

        public async Task StartAsync()
        {
            _logger.LogInformation("Starting heartbeat monitor...");
            await _heartbeat.StartAsync(_self, _peerManager.GetActivePeers());
        }

        public bool ShouldRunInRole(IList<string> roles)
            => roles.Contains(ClustronRoles.Member);

    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\Behaviors\IClusterRoleBehavior.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster.Behaviors
{
    public interface IClusterRoleBehavior
    {
        string Name { get; }
        Task StartAsync();
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\Behaviors\IRoleAwareBehavior.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster.Behaviors
{
    public interface IRoleAwareBehavior : IClusterRoleBehavior
    {
        bool ShouldRunInRole(IList<string> roles);
    }

}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\Behaviors\MetricsCollectorBehavior.cs
using Clustron.Abstractions;
using Clustron.Core.Cluster;
using Clustron.Core.Cluster.Behaviors;
using Clustron.Core.Configuration;
using Clustron.Core.Messaging;
using Clustron.Core.Models;
using Clustron.Core.Serialization;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;

namespace Clustron.Core.Cluster.Behaviors;

public class MetricsCollectorBehavior : IRoleAwareBehavior, IMetricsListener
{
    private readonly ILogger<MetricsCollectorBehavior> _logger;
    private readonly ClusterPeerManager _peerManager;
    private readonly IMessageSerializer _serializer;
    private readonly NodeInfo _self;
    private readonly IClusterCommunication _communication;
    private readonly ClustronConfig _configuration;
    private readonly ConcurrentDictionary<string, List<ClusterMetricsSnapshot>> _metricsHistory = new();
    private readonly CancellationTokenSource _cts = new();

    private static readonly TimeSpan PollInterval = TimeSpan.FromSeconds(10);
    private static readonly TimeSpan RetentionDuration = TimeSpan.FromHours(1);

    private int _isPolling = 0;

    public string Name => "MetricsCollector";

    public MetricsCollectorBehavior(
        ILogger<MetricsCollectorBehavior> logger,
        IClusterRuntime runtime,
        IMessageSerializer serializer,
        IClusterCommunication communication)
    {
        _logger = logger;
        _peerManager = runtime.PeerManager;
        _serializer = serializer;
        _self = runtime.Self;
        _communication = communication;
        _configuration = runtime.Configuration;
    }

    public bool ShouldRunInRole(IList<string> roles)
        => roles.Contains(ClustronRoles.MetricsCollector);

    public Task StartAsync()
    {
        _ = Task.Run(async () =>
        {
            using var timer = new PeriodicTimer(PollInterval);
            while (await timer.WaitForNextTickAsync(_cts.Token))
            {
                await PollMembersAsync();
            }
        }, _cts.Token);

        _logger.LogInformation("MetricsCollectorBehavior started.");
        return Task.CompletedTask;
    }

    private async Task PollMembersAsync()
    {
        if (Interlocked.Exchange(ref _isPolling, 1) == 1)
            return;

        try
        {
            var peers = _peerManager.GetPeersWithRole(ClustronRoles.Member)
                .Where(p => p.NodeId != _self.NodeId)
                .ToList();

            _logger.LogInformation("Polling {Count} members for metrics...", peers.Count);

            var tasks = peers.Select(PollPeerAsync).ToList();
            await Task.WhenAll(tasks);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during polling.");
        }
        finally
        {
            Interlocked.Exchange(ref _isPolling, 0);
        }
    }

    private async Task PollPeerAsync(NodeInfo peer)
    {
        var correlationId = Guid.NewGuid().ToString();
        var request = MessageBuilder.Create<MetricsRequest>(
            _self.NodeId,
            MessageTypes.RequestMetrics,
            correlationId,
            new MetricsRequest { DurationSeconds = (int)PollInterval.TotalSeconds });

        var timeout = TimeSpan.FromMilliseconds(_configuration.Metrics.MetricsTimeoutMilliseconds);

        try
        {
            await _communication.Transport.SendImmediateAsync(peer, request);

            var responseTask = _communication.Transport.WaitForResponseAsync(peer.NodeId, correlationId, timeout);
            var delayTask = Task.Delay(timeout);

            var completedTask = await Task.WhenAny(responseTask, delayTask);

            if (completedTask != responseTask)
            {
                throw new TimeoutException("Timed out waiting for metrics response.");
            }

            if (responseTask.IsFaulted)
            {
                throw new Exception("Request failed.", responseTask.Exception);
            }

            if (responseTask.IsCanceled)
            {
                throw new OperationCanceledException("Request was canceled.");
            }

            var response = await responseTask;
            var snapshot = _serializer.Deserialize<ClusterMetricsSnapshot>(response.Payload);

            if (snapshot != null)
                OnMetricsReceived(snapshot);
        }
        catch (TimeoutException)
        {
            _logger.LogWarning("Timeout waiting for metrics from {NodeId}", peer.NodeId);
        }
        catch (Exception ex)
        {
            _logger.LogWarning("Failed to fetch metrics from {NodeId}: {Error}", peer.NodeId, ex.Message);
        }
    }

    public void OnMetricsReceived(ClusterMetricsSnapshot snapshot)
    {
        var list = _metricsHistory.GetOrAdd(snapshot.NodeId, _ => new List<ClusterMetricsSnapshot>());
        var now = DateTime.UtcNow;

        lock (list)
        {
            list.Add(snapshot);
            list.RemoveAll(s => s.TimestampUtc < now - RetentionDuration);
        }

        LogMetrics(snapshot);
    }

    private void LogMetrics(ClusterMetricsSnapshot snapshot)
    {
        snapshot.Totals.TryGetValue(MetricKeys.Msg.Direct.Sent, out var totalDirectSent);
        snapshot.Totals.TryGetValue(MetricKeys.Msg.Direct.Broadcasted, out var totalDirectBroadcasted);
        snapshot.Totals.TryGetValue(MetricKeys.Msg.Direct.Received, out var totalDirectReceived);

        snapshot.Totals.TryGetValue(MetricKeys.Msg.Events.Published, out var totalEventsPublished);
        snapshot.Totals.TryGetValue(MetricKeys.Msg.Events.Delivered, out var totalEventsReceived);

        snapshot.Totals.TryGetValue(MetricKeys.Msg.Wire.Sent, out var totalSent);
        snapshot.Totals.TryGetValue(MetricKeys.Msg.Wire.Received, out var totalRecv);

        snapshot.Totals.TryGetValue(MetricKeys.Heartbeat.Sent, out var totalHbSent);
        snapshot.Totals.TryGetValue(MetricKeys.Heartbeat.Received, out var totalHbRecv);

        snapshot.PerSecondRates.TryGetValue(MetricKeys.Msg.Direct.Sent, out var directSentRates);
        snapshot.PerSecondRates.TryGetValue(MetricKeys.Msg.Direct.Broadcasted, out var directBroadcastedRates);
        snapshot.PerSecondRates.TryGetValue(MetricKeys.Msg.Direct.Received, out var directReceivedRates);

        snapshot.PerSecondRates.TryGetValue(MetricKeys.Msg.Events.Published, out var eventsPublishedRates);
        snapshot.PerSecondRates.TryGetValue(MetricKeys.Msg.Events.Delivered, out var eventsReceivedRates);

        snapshot.PerSecondRates.TryGetValue(MetricKeys.Msg.Wire.Sent, out var sentRates);
        snapshot.PerSecondRates.TryGetValue(MetricKeys.Msg.Wire.Received, out var recvRates);

        snapshot.PerSecondRates.TryGetValue(MetricKeys.Heartbeat.Sent, out var hbSentRates);
        snapshot.PerSecondRates.TryGetValue(MetricKeys.Heartbeat.Received, out var hbRecvRates);

        _logger.LogCritical(
            @"Received metrics from {NodeId}:

--- Direct Messages ---
  Sent:       {DirectSent}     Rate: {DirectSentRate}
  Broadcasted:{DirectBroadcasted} Rate: {DirectBroadcastedRate}
  Received:   {DirectReceived} Rate: {DirectReceivedRate}

--- Events ---
  Published:  {EventsPublished} Rate: {EventsPublishedRate}
  Delivered:  {EventsReceived} Rate: {EventsReceivedRate}

--- Wire Messages ---
  Sent:       {TotalSent}      Rate: {SentRate}
  Received:   {TotalRecv}      Rate: {RecvRate}

--- Heartbeats ---
  Sent:       {HbSent}         Rate: {HbSentRate}
  Received:   {HbRecv}         Rate: {HbRecvRate}
",
            snapshot.NodeId,
            totalDirectSent, FormatRates(directSentRates),
            totalDirectBroadcasted, FormatRates(directBroadcastedRates),
            totalDirectReceived, FormatRates(directReceivedRates),
            totalEventsPublished, FormatRates(eventsPublishedRates),
            totalEventsReceived, FormatRates(eventsReceivedRates),
            totalSent, FormatRates(sentRates),
            totalRecv, FormatRates(recvRates),
            totalHbSent, FormatRates(hbSentRates),
            totalHbRecv, FormatRates(hbRecvRates)
        );
    }

    private static string FormatRates(int[]? rates)
    {
        return (rates == null || rates.Length == 0) ? "(no data)" : $"[{string.Join(", ", rates)}]/s";
    }
}

// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\State\IClusterState.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster.State
{
    public interface IClusterState
    {
        NodeInfo? CurrentLeader { get; }
        int CurrentEpoch { get; }
        void ForceLeader(NodeInfo leader, int epoch);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\Cluster\State\IClusterStateMutator.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io

using Clustron.Core.Models;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Clustron.Core.Cluster.State
{
    public interface IClusterStateMutator : IClusterState
    {
        void SetLeader(NodeInfo leader, int epoch);
    }
}



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\obj\Debug\net9.0\.NETCoreApp,Version=v9.0.AssemblyAttributes.cs
// Copyright (c) 2025 zeroheartbeat
//
// Use of this software is governed by the Business Source License 1.1,
// included in the LICENSE file in the root of this repository.
//
// Production use is not permitted without a commercial license from the Licensor.
// To obtain a license for production, please contact: support@clustron.io
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v9.0", FrameworkDisplayName = ".NET 9.0")]


// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\obj\Debug\net9.0\Clustron.Core.AssemblyInfo.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("Clustron.Core")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+d2d272ebcef16f5aaf501d058e4496fa04a69283")]
[assembly: System.Reflection.AssemblyProductAttribute("Clustron.Core")]
[assembly: System.Reflection.AssemblyTitleAttribute("Clustron.Core")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



// File: D:\Home\Personal\projects\Clustron\src\Clustron.Core\obj\Debug\net9.0\Clustron.Core.GlobalUsings.g.cs
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;


